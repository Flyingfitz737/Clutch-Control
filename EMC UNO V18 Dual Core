// EMC Type 1 Controller - Updated with high-priority control task and deterministic loop
#include <Arduino.h>
#include <ESP32Servo.h>
#include <Preferences.h>
#include <math.h>
#include <NimBLEDevice.h>
#include <esp_task_wdt.h>
#include <LittleFS.h>
#include <FS.h>
#include <WiFi.h>
#include <string.h>

#define EPSILON 0.001
#define BLE_TX_QUEUE_SIZE 4096
#define BLE_TX_CHUNK_SIZE_MAX 240

const char* FW_VERSION="1.0.0";
const uint16_t LOG_HEADER_VERSION=2;

const int rpmSensorPin=19, potentiometerPin=34, manualPotPin=35, servoPin=18, armLightPin=2, armSwitchPin=21;
Preferences preferences;
bool settingsDirty=false;
int min_position=0, max_position=180, neutral_position=90, pidStartPosition=50, manualPotMin=0, manualPotMax=4095;
bool direction_reversed=false;
int pulsesPerRevolution=1;
volatile unsigned long lastPulseMicros=0, pulsePeriodMicros=0, pulseCount=0;
volatile bool newPeriodAvailable=false;
const unsigned long minPulsePeriodMicros=200, rpmTimeoutMicros=300000;
double rpmFilterAlpha=0.30;
int potValue=0, manualPotValue=0;

// Debounced arm switch
bool armSwitch=false;
bool armSwitchRaw=false;
bool armSwitchLastRead=false;
bool armSwitchStable=false;
unsigned long armSwitchLastChange=0;
const unsigned long armDebounceMs=50;

bool systemArmed=false;
unsigned long lastLEDFlash=0;
const unsigned long ledFlashInterval=500, ledFlashIntervalOverride=250;
bool ledState=false;
bool overrideEnabled=false, overridePending=false, overrideLatched=false, armSwitchPreviousState=false;
int overrideThresholdPct=85;
bool overrideSenseReversed=false;
const double overrideHysteresis=0.03; // hysteresis for override threshold
double setpointRPM=1000.0, currentRPM=0.0, pidOutput=0.0, Kp=2.0, Ki=5.0, Kd=1.0, pidAggressiveness=1.0;
int pidSampleTimeMs=3; // fixed 3ms ≈ 333 Hz
enum PidDirectionSetting:int{PID_DIR_DIRECT=0,PID_DIR_REVERSE=1};
PidDirectionSetting pidDirectionSetting=PID_DIR_DIRECT;
enum TelemetryMode:int{TELE_AUTO=0,TELE_ON=1,TELE_OFF=2};
TelemetryMode telemetryMode=TELE_AUTO;
bool telemetryEnabled=false;
unsigned long telemetryIntervalMs=500, lastTelemetryTime=0;
const unsigned long telemetryRateMinMs=50, telemetryRateMaxMs=5000;
const unsigned long disarmedTelemetryIntervalMs=1000;
unsigned long lastDisarmedTelemetryTime=0;
Servo clutchServo;
int servoPosition=90;
bool pidPreholdEnabled=true;
int pidFloorRawLo=0, pidFloorRawHi=180;

// Fixed-step PID state (3 ms loop)
const double pidDtSec=0.003;
const double pidDerivativeClamp=5000.0;
double pidIntegral=0.0;
double pidLastError=0.0;
bool pidFirstCompute=true;

// Override trip latch / cooldown
bool overrideTripLatched=false;
const unsigned long overrideCooldownMs=2000;
unsigned long overrideCooldownUntil=0;

// Control task timing (fixed 333 Hz)
const uint16_t controlLoopHz=333;
const TickType_t controlLoopPeriodTicks=pdMS_TO_TICKS(3);
TaskHandle_t controlTaskHandle=NULL;
volatile uint32_t controlReportMaxUs=0;
volatile bool controlReportPending=false;

class RingBuffer{
private:
  uint8_t buffer[BLE_TX_QUEUE_SIZE];
  volatile uint16_t head, tail;
public:
  RingBuffer():head(0),tail(0){}
  bool write(const char* data,size_t len){
    if(availableForWrite()<len)return false;
    for(size_t i=0;i<len;i++){buffer[head]=data[i];head=(head+1)%BLE_TX_QUEUE_SIZE;}
    return true;
  }
  size_t read(uint8_t* dest,size_t maxLen){
    size_t count=0;
    while(count<maxLen&&available()>0){dest[count++]=buffer[tail];tail=(tail+1)%BLE_TX_QUEUE_SIZE;}
    return count;
  }
  size_t available()const{return(head>=tail)?(head-tail):(BLE_TX_QUEUE_SIZE-tail+head);}
  size_t availableForWrite()const{return BLE_TX_QUEUE_SIZE-available()-1;}
  void clear(){head=tail=0;}
};

RingBuffer bleTxQueue;
TaskHandle_t bleTaskHandle=NULL;
static const char* BLE_NAME="EMC_UNO";
static NimBLEUUID NUS_SERVICE("6E400001-B5A3-F393-E0A9-E50E24DCCA9E");
static NimBLEUUID NUS_RX("6E400002-B5A3-F393-E0A9-E50E24DCCA9E");
static NimBLEUUID NUS_TX("6E400003-B5A3-F393-E0A9-E50E24DCCA9E");
static NimBLECharacteristic* txChar=nullptr;
static bool bleConnected=false, bleNotificationsEnabled=false;
static String bleRxBuf;
String inputString="";
bool stringComplete=false;
bool bleTxSuppressed=false; // suppress BLE TX while armed

// Dynamic BLE chunk size (MTU aware)
size_t bleTxChunkSize=20; // safe default for MTU 23

// Logging (LittleFS + BLE CSV)
struct LogRecord{
  uint32_t ts_ms;
  uint16_t rpm;
  uint16_t target;
  uint16_t servo;
  uint8_t flags;
  uint16_t pid_out;
};

struct LogHeader{
  char magic[4];       // "EMC1"
  uint16_t version;    // 2
  uint16_t headerSize; // sizeof(LogHeader)
  uint16_t recordSize; // 13
  uint16_t sampleHz;   // 50
  uint32_t startMs;    // millis() at start
  uint32_t eventId;    // log session id
  float kp;
  float ki;
  float kd;
  float aggr;
  uint8_t overrideEnabled;
  uint8_t overrideThresholdPct;
  uint8_t overrideSenseReversed;
  uint8_t pidDirection;
  char fwVersion[16];
};

struct LogFooter{
  char magic[4];       // "END1"
  uint32_t dropped;    // dropped count
};

const uint32_t logIntervalUs=20000; // 50 Hz
const uint16_t logSampleHz=50;
const uint32_t logFlushIntervalMs=250;
uint32_t lastLogMicros=0;
bool loggingActive=false;
String logPath="";
File logFile;
TaskHandle_t logTaskHandle=NULL;
uint32_t logStartMs=0;
bool logFinalizePending=false;
uint32_t logEventId=0;

const size_t LOG_BUFFER_SIZE=5200; // ~104s @ 50 Hz
LogRecord logBuffer[LOG_BUFFER_SIZE];
volatile uint16_t logHead=0;
volatile uint16_t logTail=0;
volatile uint32_t logDropped=0;
portMUX_TYPE logMux=portMUX_INITIALIZER_UNLOCKED;

// Log download
bool fsMounted=false;
bool logReadActive=false;
String logReadPath="";
File logReadFile;
size_t logReadSize=0;
size_t logReadSent=0;
const size_t LOG_READ_CHUNK=128;

void IRAM_ATTR rpmPulseISR();
void readSensors();
void processInput();
void processCommand(String command);
void updateSystemState();
bool attemptArm();
bool attemptArmFromSwitch();
void disarmSystem(const String &reason, bool overrideTrip=false);
void runPIDControl();
void runManualControl();
void updateOutputs();
int applyCalibration(int position);
bool processCalibrationCommand(String command);
bool processSafetyCommand(String command);
void printDetailedStatus();
void printHelp();
void printCalibrationStatus();
void saveCalibrationData();
void loadCalibrationData();
void emitGetAll();
bool emitGetKey(const String& key);
void emitTelemetryKvLine();
void emitDisarmedStatusLine();
bool rawIncreaseIncreasesCal();
void applyPidFloorLimitsWhileArmed();
void updateBleChunkSize(uint16_t mtu);
void controlTask(void* parameter);
void sendAck(const String& command, bool ok);

// Logging helpers
void startLogging();
void stopLogging();
void logSampleIfDue();
bool logPush(const LogRecord& rec);
bool logPop(LogRecord& rec);
void logServiceTask(void* parameter);
void listLogFiles();
void requestLogRead(const String& path);
void cancelLogRead();
void ioWriteBinary(const uint8_t* data,size_t len);
bool ensureLogSpace(size_t bytesNeeded);
bool deleteOldestLogFile(String& deletedPath);
bool isLogFileName(const String& name);
uint32_t parseLogTimestamp(const String& name);

const char* pidDirToString(PidDirectionSetting d){return(d==PID_DIR_REVERSE)?"REVERSE":"DIRECT";}
const char* telemetryModeToString(TelemetryMode m){switch(m){case TELE_AUTO:return"AUTO";case TELE_ON:return"ON";case TELE_OFF:return"OFF";default:return"AUTO";}}
void applyTelemetryPolicy(){if(telemetryMode==TELE_ON)telemetryEnabled=true;else if(telemetryMode==TELE_OFF)telemetryEnabled=false;else telemetryEnabled=systemArmed;}

double getManualPotNormForOverride(int rawAdc){
  const int span=manualPotMax-manualPotMin;
  if(span<=0)return 0.0;
  double norm=((double)rawAdc-(double)manualPotMin)/(double)span;
  if(norm<0.0)norm=0.0;
  if(norm>1.0)norm=1.0;
  if(overrideSenseReversed)norm=1.0-norm;
  return norm;
}

int adcToPctForOverride(int adc){
  double norm=getManualPotNormForOverride(adc);
  int pct=(int)lround(norm*100.0);
  return constrain(pct,0,100);
}

int pctToAdcForOverride(int pct){
  pct=constrain(pct,0,100);
  const int span=manualPotMax-manualPotMin;
  if(span<=0)return manualPotMin;
  double norm=(double)pct/100.0;
  if(overrideSenseReversed)norm=1.0-norm;
  int adc=(int)lround((double)manualPotMin+norm*(double)span);
  return constrain(adc,manualPotMin,manualPotMax);
}

bool setOverrideThresholdPct(int pct){
  if(pct<0||pct>100)return false;
  if(pct==overrideThresholdPct){Serial.println("Override threshold unchanged ("+String(overrideThresholdPct)+"%)");return true;}
  overrideThresholdPct=pct;
  settingsDirty=true;
  Serial.println("Safety threshold set to: "+String(overrideThresholdPct)+"% | sense: "+String(overrideSenseReversed?"REVERSED":"NORMAL")+" | (UNSAVED)");
  return true;
}

bool setOverrideSenseReversed(bool reversed){
  if(overrideSenseReversed==reversed){Serial.println("Override sense unchanged ("+String(overrideSenseReversed?"REVERSED":"NORMAL")+")");return true;}
  overrideSenseReversed=reversed;
  settingsDirty=true;
  Serial.println("Override sense set to: "+String(overrideSenseReversed?"REVERSED":"NORMAL")+" | threshold: "+String(overrideThresholdPct)+"% | (UNSAVED)");
  return true;
}

bool setOverrideThresholdAdcLegacy(int adc){
  adc=constrain(adc,manualPotMin,manualPotMax);
  int pct=adcToPctForOverride(adc);
  overrideThresholdPct=pct;
  settingsDirty=true;
  Serial.println("Safety threshold set from ADC: "+String(adc)+" -> "+String(overrideThresholdPct)+"% | sense: "+String(overrideSenseReversed?"REVERSED":"NORMAL")+" | (UNSAVED)");
  return true;
}

bool setPidDirectionSetting(PidDirectionSetting d){
  if(d!=PID_DIR_DIRECT&&d!=PID_DIR_REVERSE)return false;
  if(systemArmed){Serial.println("PID DIRECTION CHANGE REJECTED: system is ARMED. Disarm first.");return false;}
  if(pidDirectionSetting==d){Serial.println("PID direction unchanged ("+String(pidDirToString(pidDirectionSetting))+")");return true;}
  pidDirectionSetting=d;
  settingsDirty=true;
  Serial.println("PID direction set to: "+String(pidDirToString(pidDirectionSetting))+" | (UNSAVED)");
  return true;
}

bool rawIncreaseIncreasesCal(){
  int a=applyCalibration(min_position);
  int b=applyCalibration(max_position);
  return(b>a);
}

void applyPidFloorLimitsWhileArmed(){
  if(!systemArmed||!pidPreholdEnabled){
    pidFloorRawLo=min_position;
    pidFloorRawHi=max_position;
    return;
  }
  int startRaw=constrain(pidStartPosition,min_position,max_position);
  if(rawIncreaseIncreasesCal()){
    pidFloorRawLo=startRaw;
    pidFloorRawHi=max_position;
  }else{
    pidFloorRawLo=min_position;
    pidFloorRawHi=startRaw;
  }
}

bool bleSendAsync(const char* data,size_t len){
  if(!bleConnected || bleTxSuppressed)return false;
  if(!bleTxQueue.write(data,len)){
    static unsigned long lastWarn=0;
    if(millis()-lastWarn>1000){
      Serial.println("[BLE WARN] queue full; data dropped");
      lastWarn=millis();
    }
    return false;
  }
  return true;
}
bool bleSendAsync(const String& s){return bleSendAsync(s.c_str(),s.length());}
bool bleSendLineAsync(const String& s){String line=s+"\n";return bleSendAsync(line.c_str(),line.length());}
void ioPrintln(const String& s){Serial.println(s);if(bleConnected)bleSendLineAsync(s);}
void ioPrint(const String& s){Serial.print(s);if(bleConnected)bleSendAsync(s);}
void ioWriteBinary(const uint8_t* data,size_t len){Serial.write(data,len);if(bleConnected)bleSendAsync((const char*)data,len);}

void updateBleChunkSize(uint16_t mtu){
  if(mtu < 23) mtu = 23;
  size_t payload = (mtu > 3) ? (mtu - 3) : 20;
  if(payload > BLE_TX_CHUNK_SIZE_MAX) payload = BLE_TX_CHUNK_SIZE_MAX;
  if(payload < 20) payload = 20;
  bleTxChunkSize = payload;
  Serial.println("[BLE] MTU="+String(mtu)+" -> chunk="+String(bleTxChunkSize));
}

void bleServiceTask(void* parameter){
  uint8_t chunk[BLE_TX_CHUNK_SIZE_MAX];
  TickType_t lastTransmit=0;
  const TickType_t minTxDelay=pdMS_TO_TICKS(10);
  Serial.println("[BLE TASK] Started on core "+String(xPortGetCoreID()));
  while(true){
    if(bleConnected&&bleNotificationsEnabled&&bleTxQueue.available()>0){
      TickType_t now=xTaskGetTickCount();
      if(now-lastTransmit<minTxDelay)vTaskDelay(minTxDelay-(now-lastTransmit));
      size_t bytesToSend=bleTxQueue.read(chunk,bleTxChunkSize);
      if(bytesToSend>0){txChar->setValue(chunk,bytesToSend);txChar->notify();lastTransmit=xTaskGetTickCount();}
    }else{vTaskDelay(pdMS_TO_TICKS(5));}
  }
}

class ServerCallbacks:public NimBLEServerCallbacks{
  void onConnect(NimBLEServer* pServer,NimBLEConnInfo& connInfo){
    bleConnected=true;
    Serial.println("\n[BLE] CLIENT CONNECTED");
    updateBleChunkSize(connInfo.getMTU());
  }
  void onDisconnect(NimBLEServer* pServer,NimBLEConnInfo& connInfo,int reason){
    bleConnected=false;bleNotificationsEnabled=false;
    Serial.println("\n[BLE] CLIENT DISCONNECTED");
    NimBLEDevice::startAdvertising();
  }
  void onMTUChange(uint16_t MTU, NimBLEConnInfo& connInfo){
    updateBleChunkSize(MTU);
  }
};

class RxCallbacks:public NimBLECharacteristicCallbacks{
  void onWrite(NimBLECharacteristic* pCharacteristic,NimBLEConnInfo& connInfo){
    std::string v=pCharacteristic->getValue();
    if(v.empty())return;
    for(char ch:v){
      if(ch=='\r')continue;
      if(ch=='\n'){
        String line=bleRxBuf;
        bleRxBuf="";
        line.trim();
        if(line.length()){Serial.println(">> "+line);processCommand(line);}
      }else{if(bleRxBuf.length()<240)bleRxBuf+=ch;}
    }
  }
};

class TxCallbacks:public NimBLECharacteristicCallbacks{
  void onSubscribe(NimBLECharacteristic* pCharacteristic,NimBLEConnInfo& connInfo,uint16_t subValue){
    bleNotificationsEnabled=(subValue!=0);
    Serial.println("[BLE TX] Notifications: "+String(bleNotificationsEnabled?"ENABLED":"DISABLED"));
  }
};

void bleInit(){
  Serial.println("[BLE] Initializing...");
  NimBLEDevice::init(BLE_NAME);
  NimBLEDevice::setPower(ESP_PWR_LVL_P9);
  NimBLEDevice::setMTU(247);
  NimBLEServer* server=NimBLEDevice::createServer();
  server->setCallbacks(new ServerCallbacks());
  NimBLEService* svc=server->createService(NUS_SERVICE);
  txChar=svc->createCharacteristic(NUS_TX,NIMBLE_PROPERTY::READ|NIMBLE_PROPERTY::NOTIFY|NIMBLE_PROPERTY::INDICATE);
  txChar->setValue("");
  NimBLEDescriptor* txDesc=txChar->createDescriptor(NimBLEUUID((uint16_t)0x2902),NIMBLE_PROPERTY::READ|NIMBLE_PROPERTY::WRITE);
  uint8_t descVal[2]={0x01,0x00};
  txDesc->setValue(descVal,2);
  txChar->setCallbacks(new TxCallbacks());
  bleNotificationsEnabled=true;
  NimBLECharacteristic* rx=svc->createCharacteristic(NUS_RX,NIMBLE_PROPERTY::WRITE|NIMBLE_PROPERTY::WRITE_NR);
  rx->setCallbacks(new RxCallbacks());
  svc->start();
  NimBLEAdvertising* adv=NimBLEDevice::getAdvertising();
  adv->addServiceUUID(NUS_SERVICE);
  adv->setMinInterval(100);
  adv->setMaxInterval(200);
  adv->start();
  Serial.println("[BLE] Initialized");
}

String kv(const char* k,const String& v){return String(k)+"="+v;}
String kv(const char* k,double v,int dp=2){return String(k)+"="+String(v,dp);}
String kv(const char* k,int v){return String(k)+"="+String(v);}
String modeString(){return systemArmed?"AUTO":"MANUAL";}

void sendAck(const String& command, bool ok){
  ioPrintln("ack ts="+String(millis())+" cmd="+command+" ok="+String(ok?1:0));
}

// Logging helpers
bool isLogFileName(const String& name){
  return name.startsWith("/log_") && name.endsWith(".bin");
}

uint32_t parseLogTimestamp(const String& name){
  String n=name;
  n.replace("/log_","");
  n.replace(".bin","");
  return (uint32_t)n.toInt();
}

bool deleteOldestLogFile(String& deletedPath){
  File root=LittleFS.open("/");
  if(!root) return false;
  File f=root.openNextFile();
  bool found=false;
  uint32_t oldestTs=0xFFFFFFFF;
  String oldestName="";
  while(f){
    String name=String(f.name());
    if(!f.isDirectory() && isLogFileName(name)){
      uint32_t ts=parseLogTimestamp(name);
      if(ts<oldestTs){
        oldestTs=ts;
        oldestName=name;
        found=true;
      }
    }
    f=root.openNextFile();
  }
  if(found && oldestName.length()>0){
    if(oldestName==logPath) return false;
    LittleFS.remove(oldestName);
    deletedPath=oldestName;
    return true;
  }
  return false;
}

bool ensureLogSpace(size_t bytesNeeded){
  if(!fsMounted) return false;
  size_t total=LittleFS.totalBytes();
  size_t used=LittleFS.usedBytes();
  size_t freeBytes=(total>used)?(total-used):0;
  const size_t reserve=512;
  if(freeBytes>=bytesNeeded+reserve) return true;

  String deleted;
  while(freeBytes < bytesNeeded+reserve){
    bool ok=deleteOldestLogFile(deleted);
    if(!ok) break;
    used=LittleFS.usedBytes();
    freeBytes=(total>used)?(total-used):0;
  }
  return freeBytes>=bytesNeeded+reserve;
}

bool logPush(const LogRecord& rec){
  portENTER_CRITICAL(&logMux);
  uint16_t next=(logHead+1)%LOG_BUFFER_SIZE;
  if(next==logTail){
    logTail=(logTail+1)%LOG_BUFFER_SIZE; // drop oldest
    logDropped++;
  }
  logBuffer[logHead]=rec;
  logHead=next;
  portEXIT_CRITICAL(&logMux);
  return true;
}

bool logPop(LogRecord& rec){
  portENTER_CRITICAL(&logMux);
  if(logTail==logHead){
    portEXIT_CRITICAL(&logMux);
    return false;
  }
  rec=logBuffer[logTail];
  logTail=(logTail+1)%LOG_BUFFER_SIZE;
  portEXIT_CRITICAL(&logMux);
  return true;
}

void startLogging(){
  if(loggingActive) return;
  if(!fsMounted){
    ioPrintln("LOG ERR: LittleFS not mounted");
    return;
  }
  portENTER_CRITICAL(&logMux);
  logHead=0;
  logTail=0;
  logDropped=0;
  portEXIT_CRITICAL(&logMux);
  loggingActive=true;
  lastLogMicros=0;
  logStartMs=millis();
  logFinalizePending=false;

  preferences.begin("emc_logs",false);
  logEventId=preferences.getUInt("log_seq",0)+1;
  preferences.putUInt("log_seq",logEventId);
  preferences.end();

  logPath="/log_"+String(logEventId)+"_"+String(logStartMs)+".bin";
  ioPrintln("LOG START: "+logPath);
}

void stopLogging(){
  if(!loggingActive) return;
  loggingActive=false;
  logFinalizePending=true;
  ioPrintln("LOG STOP");
}

void logSampleIfDue(){
  if(!systemArmed || !loggingActive) return;
  uint32_t nowMicros=micros();
  if(lastLogMicros==0) lastLogMicros=nowMicros;
  if((nowMicros - lastLogMicros) < logIntervalUs) return;
  lastLogMicros += logIntervalUs;

  uint8_t flags=0;
  if(systemArmed) flags|=0x01;
  if(overrideEnabled) flags|=0x02;
  if(overridePending) flags|=0x04;
  if(overrideLatched) flags|=0x08;
  if(overrideTripLatched) flags|=0x10;

  LogRecord rec;
  rec.ts_ms=millis();
  rec.rpm=(uint16_t)constrain((int)lround(currentRPM),0,65535);
  rec.target=(uint16_t)constrain((int)lround(setpointRPM),0,65535);
  rec.servo=(uint16_t)constrain(servoPosition,0,65535);
  rec.flags=flags;
  rec.pid_out=(uint16_t)constrain((int)lround(pidOutput),0,65535);

  logPush(rec);
}

void listLogFiles(){
  if(!fsMounted){ioPrintln("err=fs_not_mounted");return;}
  File root=LittleFS.open("/");
  if(!root){ioPrintln("err=fs_open");return;}
  ioPrintln("log_list_begin");
  File f=root.openNextFile();
  while(f){
    String name=String(f.name());
    if(!f.isDirectory() && isLogFileName(name)){
      ioPrintln("log_file="+name+" size="+String((unsigned long)f.size()));
    }
    f=root.openNextFile();
  }
  ioPrintln("log_list_end");
}

void requestLogRead(const String& path){
  if(!fsMounted){ioPrintln("err=fs_not_mounted");return;}
  if(logReadActive){ioPrintln("err=logread_busy");return;}
  if(systemArmed){ioPrintln("err=logread_armed");return;}
  if(loggingActive || logFinalizePending || logFile){ioPrintln("err=log_not_final");return;}
  String p=path;
  p.trim();
  if(!p.startsWith("/")) p="/"+p;
  logReadPath=p;
  logReadActive=true;
  logReadSent=0;
  logReadSize=0;
  ioPrintln("logread_start "+logReadPath);
}

void cancelLogRead(){
  if(logReadActive){logReadActive=false;}
  if(logReadFile){logReadFile.close();}
  ioPrintln("logread_cancel");
}

void logServiceTask(void* parameter){
  Serial.println("[LOG TASK] Started on core "+String(xPortGetCoreID()));
  LogRecord rec;
  uint8_t binBuf[13];
  char csvBuf[96];
  uint8_t readBuf[LOG_READ_CHUNK];
  uint32_t lastFlushMs=0;

  while(true){
    if(!logFile && (loggingActive || logFinalizePending || logTail!=logHead)){
      ensureLogSpace(sizeof(LogHeader));
      logFile=LittleFS.open(logPath,"w");
      if(!logFile){
        Serial.println("[LOG ERR] Failed to open file");
      }else{
        LogHeader hdr;
        memcpy(hdr.magic,"EMC1",4);
        hdr.version=LOG_HEADER_VERSION;
        hdr.headerSize=sizeof(LogHeader);
        hdr.recordSize=13;
        hdr.sampleHz=logSampleHz;
        hdr.startMs=logStartMs;
        hdr.eventId=logEventId;
        hdr.kp=(float)Kp;
        hdr.ki=(float)Ki;
        hdr.kd=(float)Kd;
        hdr.aggr=(float)pidAggressiveness;
        hdr.overrideEnabled=overrideEnabled?1:0;
        hdr.overrideThresholdPct=(uint8_t)overrideThresholdPct;
        hdr.overrideSenseReversed=overrideSenseReversed?1:0;
        hdr.pidDirection=(uint8_t)pidDirectionSetting;
        memset(hdr.fwVersion,0,sizeof(hdr.fwVersion));
        strncpy(hdr.fwVersion,FW_VERSION,sizeof(hdr.fwVersion)-1);
        logFile.write((uint8_t*)&hdr,sizeof(hdr));
        lastFlushMs=millis();
      }
    }

    // Log download handling (only allowed when disarmed)
    if(logReadActive){
      if(!logReadFile){
        logReadFile=LittleFS.open(logReadPath,"r");
        if(!logReadFile){
          ioPrintln("logread_err open_failed");
          logReadActive=false;
        }else{
          logReadSize=logReadFile.size();
          logReadSent=0;
          ioPrintln("logfile_begin "+logReadPath+" size="+String((unsigned long)logReadSize)+" format=bin record_size=13 header_size="+String((unsigned long)sizeof(LogHeader))+" footer_size="+String((unsigned long)sizeof(LogFooter)));
        }
      }
      if(logReadFile){
        size_t n=logReadFile.read(readBuf,LOG_READ_CHUNK);
        if(n>0){
          ioWriteBinary(readBuf,n);
          logReadSent+=n;
        }
        if(n==0 || logReadSent>=logReadSize){
          logReadFile.close();
          logReadActive=false;
          ioPrintln("\nlogfile_end "+logReadPath);
        }
      }
    }

    while(logPop(rec)){
      // Binary write (13 bytes)
      binBuf[0]=(rec.ts_ms>>0)&0xFF;
      binBuf[1]=(rec.ts_ms>>8)&0xFF;
      binBuf[2]=(rec.ts_ms>>16)&0xFF;
      binBuf[3]=(rec.ts_ms>>24)&0xFF;
      binBuf[4]=(rec.rpm>>0)&0xFF;
      binBuf[5]=(rec.rpm>>8)&0xFF;
      binBuf[6]=(rec.target>>0)&0xFF;
      binBuf[7]=(rec.target>>8)&0xFF;
      binBuf[8]=(rec.servo>>0)&0xFF;
      binBuf[9]=(rec.servo>>8)&0xFF;
      binBuf[10]=rec.flags;
      binBuf[11]=(rec.pid_out>>0)&0xFF;
      binBuf[12]=(rec.pid_out>>8)&0xFF;

      if(logFile){
        if(ensureLogSpace(sizeof(binBuf))){
          logFile.write(binBuf,sizeof(binBuf));
        }
      }

      // BLE CSV stream only when disarmed
      if(!systemArmed && bleConnected && bleTxQueue.availableForWrite() > 256){
        int n=snprintf(csvBuf,sizeof(csvBuf),"log %lu,%u,%u,%u,%u,%u\n",
          (unsigned long)rec.ts_ms,rec.rpm,rec.target,rec.servo,rec.flags,rec.pid_out);
        if(n>0) bleSendAsync(csvBuf,(size_t)n);
      }
    }

    if(logFile && (millis()-lastFlushMs>=logFlushIntervalMs)){
      logFile.flush();
      lastFlushMs=millis();
    }

    if(logFile && logFinalizePending && logTail==logHead){
      LogFooter ft;
      memcpy(ft.magic,"END1",4);
      ft.dropped=logDropped;
      logFile.write((uint8_t*)&ft,sizeof(ft));
      logFile.flush();
      logFile.close();
      logFinalizePending=false;
      ioPrintln("LOG FINALIZED: "+logPath);
    }

    vTaskDelay(pdMS_TO_TICKS(5));
  }
}

void emitGetAll(){
  Serial.println("[CMD] getall");
  uint32_t cooldownRemaining=(overrideCooldownUntil>millis())?(overrideCooldownUntil-millis()):0;
  String allData="";
  allData.reserve(1280);
  allData+=kv("rpm",(int)lround(currentRPM))+"\n";
  allData+=kv("target",(int)lround(setpointRPM))+"\n";
  allData+=kv("servo",servoPosition)+"\n";
  allData+=kv("mode",modeString())+"\n";
  allData+=kv("kp",String(Kp,6))+"\n";
  allData+=kv("ki",String(Ki,6))+"\n";
  allData+=kv("kd",String(Kd,6))+"\n";
  allData+=kv("aggr",String(pidAggressiveness,3))+"\n";
  allData+=kv("ppr",pulsesPerRevolution)+"\n";
  allData+=kv("ts",pidSampleTimeMs)+"\n";
  allData+=kv("alpha",String(rpmFilterAlpha,3))+"\n";
  allData+=kv("pid_dir",pidDirToString(pidDirectionSetting))+"\n";
  allData+=kv("tele_mode",telemetryModeToString(telemetryMode))+"\n";
  allData+=kv("tele_ms",(int)telemetryIntervalMs)+"\n";
  allData+=kv("override_en",overrideEnabled?1:0)+"\n";
  allData+=kv("ov_thr_pct",overrideThresholdPct)+"\n";
  allData+=kv("ov_sense",overrideSenseReversed?1:0)+"\n";
  allData+=kv("pending",overridePending?1:0)+"\n";
  allData+=kv("latched",overrideLatched?1:0)+"\n";
  allData+=kv("ov_trip",overrideTripLatched?1:0)+"\n";
  allData+=kv("cooldown_ms",(int)cooldownRemaining)+"\n";
  allData+=kv("prehold",pidPreholdEnabled?1:0)+"\n";
  allData+=kv("start_pos",pidStartPosition)+"\n";
  allData+=kv("dirty",settingsDirty?1:0)+"\n";
  allData+=kv("min_pos",min_position)+"\n";
  allData+=kv("max_pos",max_position)+"\n";
  allData+=kv("neutral_pos",neutral_position)+"\n";
  allData+=kv("cal_dir",direction_reversed?1:0)+"\n";
  allData+=kv("pot_min",manualPotMin)+"\n";
  allData+=kv("pot_max",manualPotMax)+"\n";
  allData+=kv("pid_floor_lo",pidFloorRawLo)+"\n";
  allData+=kv("pid_floor_hi",pidFloorRawHi)+"\n";
  allData+="end\n";
  Serial.print(allData);
  if(bleConnected)bleSendAsync(allData);
}

bool emitGetKey(const String& key){
  uint32_t cooldownRemaining=(overrideCooldownUntil>millis())?(overrideCooldownUntil-millis()):0;
  String k=key;k.toLowerCase();
  if(k=="rpm")ioPrintln(kv("rpm",(int)lround(currentRPM)));
  else if(k=="target")ioPrintln(kv("target",(int)lround(setpointRPM)));
  else if(k=="servo")ioPrintln(kv("servo",servoPosition));
  else if(k=="mode")ioPrintln(kv("mode",modeString()));
  else if(k=="kp")ioPrintln(kv("kp",String(Kp,6)));
  else if(k=="ki")ioPrintln(kv("ki",String(Ki,6)));
  else if(k=="kd")ioPrintln(kv("kd",String(Kd,6)));
  else if(k=="aggr")ioPrintln(kv("aggr",String(pidAggressiveness,3)));
  else if(k=="ppr")ioPrintln(kv("ppr",pulsesPerRevolution));
  else if(k=="ts")ioPrintln(kv("ts",pidSampleTimeMs));
  else if(k=="alpha")ioPrintln(kv("alpha",String(rpmFilterAlpha,3)));
  else if(k=="pid_dir")ioPrintln(kv("pid_dir",pidDirToString(pidDirectionSetting)));
  else if(k=="tele_mode")ioPrintln(kv("tele_mode",telemetryModeToString(telemetryMode)));
  else if(k=="tele_ms")ioPrintln(kv("tele_ms",(int)telemetryIntervalMs));
  else if(k=="override_en")ioPrintln(kv("override_en",overrideEnabled?1:0));
  else if(k=="ov_thr_pct")ioPrintln(kv("ov_thr_pct",overrideThresholdPct));
  else if(k=="ov_sense")ioPrintln(kv("ov_sense",overrideSenseReversed?1:0));
  else if(k=="pending")ioPrintln(kv("pending",overridePending?1:0));
  else if(k=="latched")ioPrintln(kv("latched",overrideLatched?1:0));
  else if(k=="ov_trip")ioPrintln(kv("ov_trip",overrideTripLatched?1:0));
  else if(k=="cooldown_ms")ioPrintln(kv("cooldown_ms",(int)cooldownRemaining));
  else if(k=="prehold")ioPrintln(kv("prehold",pidPreholdEnabled?1:0));
  else if(k=="start_pos")ioPrintln(kv("start_pos",pidStartPosition));
  else if(k=="dirty")ioPrintln(kv("dirty",settingsDirty?1:0));
  else if(k=="min_pos")ioPrintln(kv("min_pos",min_position));
  else if(k=="max_pos")ioPrintln(kv("max_pos",max_position));
  else if(k=="neutral_pos")ioPrintln(kv("neutral_pos",neutral_position));
  else if(k=="cal_dir")ioPrintln(kv("cal_dir",direction_reversed?1:0));
  else if(k=="pot_min")ioPrintln(kv("pot_min",manualPotMin));
  else if(k=="pot_max")ioPrintln(kv("pot_max",manualPotMax));
  else if(k=="pid_floor_lo")ioPrintln(kv("pid_floor_lo",pidFloorRawLo));
  else if(k=="pid_floor_hi")ioPrintln(kv("pid_floor_hi",pidFloorRawHi));
  else return false;
  return true;
}

void emitTelemetryKvLine(){
  if(!telemetryEnabled) return;
  if(bleTxQueue.availableForWrite() < 128)return; // prevent bursting when queue is nearly full
  static char telebuf[160];
  snprintf(telebuf,sizeof(telebuf),"tele rpm=%d target=%d servo=%d mode=%s pid_out=%d prehold=%d dirty=%d\n",
    (int)lround(currentRPM),(int)lround(setpointRPM),servoPosition,systemArmed?"AUTO":"MANUAL",
    (int)lround(pidOutput),pidPreholdEnabled?1:0,settingsDirty?1:0);
  if(bleConnected)bleSendAsync(telebuf,strlen(telebuf));
}

void emitDisarmedStatusLine(){
  if(bleTxQueue.availableForWrite() < 128)return;
  uint32_t cooldownRemaining=(overrideCooldownUntil>millis())?(overrideCooldownUntil-millis()):0;
  static char buf[180];
  snprintf(buf,sizeof(buf),"status rpm=%d target=%d servo=%d armed=0 ov_trip=%d cooldown_ms=%lu\n",
    (int)lround(currentRPM),(int)lround(setpointRPM),servoPosition,overrideTripLatched?1:0,(unsigned long)cooldownRemaining);
  if(bleConnected)bleSendAsync(buf,strlen(buf));
}

void setup(){
  Serial.begin(115200);
  delay(1500);
  Serial.println("\n========================================");
  Serial.println("  EMC Type 1 Controller");
  Serial.println("  NON-BLOCKING BLE + WATCHDOG");
  Serial.println("========================================\n");

  WiFi.mode(WIFI_OFF);

  // Reconfigure TWDT timeout to tolerate long control-loop bursts
  esp_task_wdt_config_t wdt_config = {
    .timeout_ms = 8000,
    .idle_core_mask = 0,
    .trigger_panic = true
  };
  esp_err_t wdt_err = esp_task_wdt_init(&wdt_config);
  if(wdt_err == ESP_ERR_INVALID_STATE){
    esp_task_wdt_deinit();
    esp_task_wdt_init(&wdt_config);
  }
  esp_task_wdt_add(NULL); // register loopTask
  Serial.println("✅ Watchdog enabled");

  fsMounted=LittleFS.begin(true);
  if(!fsMounted){
    Serial.println("❌ LittleFS mount failed");
  }else{
    Serial.println("✅ LittleFS mounted");
  }

  loadCalibrationData();
  settingsDirty=false;
  bleInit();

  // Pin BLE + LOG to core 0, CTRL to core 1
  xTaskCreatePinnedToCore(bleServiceTask,"BLE_TX_Task",4096,NULL,1,&bleTaskHandle,0);
  xTaskCreatePinnedToCore(logServiceTask,"LOG_Task",4096,NULL,1,&logTaskHandle,0);
  xTaskCreatePinnedToCore(controlTask,"CTRL_Task",4096,NULL,3,&controlTaskHandle,1);
  esp_task_wdt_add(controlTaskHandle);

  Serial.println("✅ BLE task started");
  Serial.println("✅ LOG task started");
  Serial.println("✅ CTRL task started");
  Serial.println("[TASKS] BLE + LOG pinned to core 0, CTRL pinned to core 1");

  pinMode(rpmSensorPin,INPUT_PULLUP);
  pinMode(potentiometerPin,INPUT);
  pinMode(manualPotPin,INPUT);
  pinMode(armLightPin,OUTPUT);
  pinMode(armSwitchPin,INPUT_PULLUP);

  analogReadResolution(12);
  analogSetPinAttenuation(potentiometerPin,ADC_11db);
  analogSetPinAttenuation(manualPotPin,ADC_11db);

  attachInterrupt(digitalPinToInterrupt(rpmSensorPin),rpmPulseISR,FALLING);

  clutchServo.attach(servoPin);
  servoPosition=neutral_position;
  clutchServo.write(servoPosition);

  systemArmed=false;
  applyPidFloorLimitsWhileArmed();
  digitalWrite(armLightPin,LOW);
  inputString.reserve(200);
  overridePending=false;
  overrideLatched=false;
  applyTelemetryPolicy();

  Serial.println("========================================");
  ioPrintln("=== EMC READY ===");
  printCalibrationStatus();
  Serial.println("========================================\n");
}

void loop(){
  esp_task_wdt_reset();
  processInput();

  if(telemetryEnabled&&(millis()-lastTelemetryTime>=telemetryIntervalMs)){
    emitTelemetryKvLine();
    lastTelemetryTime=millis();
  }

  if(!systemArmed && telemetryMode!=TELE_OFF && (millis()-lastDisarmedTelemetryTime>=disarmedTelemetryIntervalMs)){
    emitDisarmedStatusLine();
    lastDisarmedTelemetryTime=millis();
  }

  if(controlReportPending){
    if(controlReportMaxUs>1000){
      Serial.println("[PERF] CTRL Max loop: "+String(controlReportMaxUs)+" µs");
    }
    controlReportPending=false;
  }

  vTaskDelay(pdMS_TO_TICKS(1));
}

void controlTask(void* parameter){
  TickType_t lastWake=xTaskGetTickCount();
  uint32_t lastReportMs=millis();
  uint32_t maxLoopUs=0;
  uint16_t overrunCount=0;
  uint32_t lastOverrunWarnMs=0;

  while(true){
    esp_task_wdt_reset();

    uint32_t loopStart=micros();

    readSensors();
    updateSystemState();
    if(systemArmed)runPIDControl();
    else runManualControl();
    updateOutputs();
    logSampleIfDue();

    uint32_t loopTime=micros()-loopStart;
    if(loopTime>maxLoopUs)maxLoopUs=loopTime;

    if(loopTime>3000){
      if(overrunCount<200)overrunCount++;
    }else if(overrunCount>0){
      overrunCount--;
    }

    uint32_t nowMs=millis();
    if(overrunCount>=10 && (nowMs-lastOverrunWarnMs>1000)){
      Serial.println("[WARN] CTRL loop >3000us consistently");
      overrunCount=0;
      lastOverrunWarnMs=nowMs;
    }

    if(nowMs-lastReportMs>=5000){
      controlReportMaxUs=maxLoopUs;
      controlReportPending=true;
      maxLoopUs=0;
      lastReportMs=nowMs;
    }

    // Yield briefly on overrun to avoid starving IDLE task
    if(loopTime > (1000000UL / controlLoopHz)){
      vTaskDelay(pdMS_TO_TICKS(1));
    }

    vTaskDelayUntil(&lastWake, controlLoopPeriodTicks);
  }
}

void IRAM_ATTR rpmPulseISR(){
  const unsigned long now=micros();
  const unsigned long dt=now-lastPulseMicros;
  if(dt>=minPulsePeriodMicros){
    lastPulseMicros=now;
    pulsePeriodMicros=dt;
    newPeriodAvailable=true;
    pulseCount++;
  }
}

void readSensors(){
  const unsigned long now=micros();
  unsigned long period,lastPulse;
  bool hasNew;
  noInterrupts();
  period=pulsePeriodMicros;
  lastPulse=lastPulseMicros;
  hasNew=newPeriodAvailable;
  newPeriodAvailable=false;
  interrupts();

  if(now-lastPulse>rpmTimeoutMicros){
    currentRPM=0.0;
  }else if(hasNew&&period>0&&pulsesPerRevolution>0){
    const double rpmInstant=60000000.0/(period*(double)pulsesPerRevolution);
    if(rpmInstant>0.0&&rpmInstant<50000.0){
      if(currentRPM<=EPSILON)currentRPM=rpmInstant;
      else currentRPM=(1.0-rpmFilterAlpha)*currentRPM+rpmFilterAlpha*rpmInstant;
    }
  }
  potValue=analogRead(potentiometerPin);
  manualPotValue=analogRead(manualPotPin);

  // Debounce arm switch
  armSwitchRaw=!digitalRead(armSwitchPin);
  if(armSwitchRaw!=armSwitchLastRead){
    armSwitchLastRead=armSwitchRaw;
    armSwitchLastChange=millis();
  }
  if(millis()-armSwitchLastChange>=armDebounceMs){
    armSwitchStable=armSwitchLastRead;
  }
  armSwitch=armSwitchStable;
}

void runPIDControl(){
  double error=setpointRPM-currentRPM;
  if(pidDirectionSetting==PID_DIR_REVERSE) error=-error;

  if(pidFirstCompute){
    pidLastError=error;
    pidIntegral=0.0;
    pidFirstCompute=false;
  }

  if(currentRPM<=EPSILON){
    pidIntegral=0.0;
    pidLastError=error;
  }

  double derivative=(error-pidLastError)/pidDtSec;
  derivative=constrain(derivative,-pidDerivativeClamp,pidDerivativeClamp);

  pidIntegral+=error*pidDtSec;

  double integralTerm=Ki*pidIntegral;
  integralTerm=constrain(integralTerm,(double)pidFloorRawLo,(double)pidFloorRawHi);
  if(Ki!=0.0) pidIntegral=integralTerm/Ki;

  double rawOutput=(Kp*error)+integralTerm+(Kd*derivative);
  pidOutput=constrain(rawOutput,(double)pidFloorRawLo,(double)pidFloorRawHi);

  double scaledOutput=pidOutput*pidAggressiveness;
  scaledOutput=constrain(scaledOutput,(double)pidFloorRawLo,(double)pidFloorRawHi);
  int cmdCal=applyCalibration((int)lround(scaledOutput));
  if(systemArmed&&pidPreholdEnabled){
    int floorCal=applyCalibration(pidStartPosition);
    if(cmdCal<floorCal)cmdCal=floorCal;
  }
  servoPosition=constrain(cmdCal,min_position,max_position);
  clutchServo.write(servoPosition);

  pidLastError=error;
}

void runManualControl(){
  int rawPosition=map(manualPotValue,manualPotMin,manualPotMax,min_position,max_position);
  rawPosition=constrain(rawPosition,min_position,max_position);
  int cmdCal=applyCalibration(rawPosition);
  servoPosition=constrain(cmdCal,min_position,max_position);
  clutchServo.write(servoPosition);
}

void updateSystemState(){
  bool armSwitchCurrentState=armSwitch;
  if(!overrideEnabled){overridePending=false;overrideLatched=false;}
  static bool wasOverridePending=false;
  if(overrideEnabled&&systemArmed){
    const double manualNorm=getManualPotNormForOverride(manualPotValue);
    const double threshNorm=(double)overrideThresholdPct/100.0;
    const double recoverNorm=(threshNorm-overrideHysteresis<0.0)?0.0:(threshNorm-overrideHysteresis);
    if(manualNorm>=threshNorm){
      overridePending=true;
      if(!wasOverridePending)ioPrintln("OVERRIDE PENDING: manual pot >= threshold; PID remains ACTIVE.");
    }
    if(overridePending&&(manualNorm<recoverNorm)){
      disarmSystem("OVERRIDE RECOVERED: manual pot below threshold; now MANUAL.",true);
      overrideLatched=true;
      ioPrintln("OVERRIDE LATCHED: requires ARM SWITCH re-arm.");
    }
  }
  wasOverridePending=overridePending;
  if(armSwitchCurrentState&&!armSwitchPreviousState)attemptArmFromSwitch();
  else if(!armSwitchCurrentState&&armSwitchPreviousState&&systemArmed)disarmSystem("System DISARMED via switch");
  armSwitchPreviousState=armSwitchCurrentState;
}

bool attemptArm(){
  if(overrideEnabled){
    const double manualNorm=getManualPotNormForOverride(manualPotValue);
    const double threshNorm=(double)overrideThresholdPct/100.0;
    if(manualNorm>=threshNorm){ioPrintln("Cannot arm: manual pot at/above threshold.");return false;}
  }
  if(millis()<overrideCooldownUntil){
    ioPrintln("Cannot arm: cooldown active ("+String(overrideCooldownUntil-millis())+" ms)");
    return false;
  }
  servoPosition=constrain(applyCalibration(pidStartPosition),min_position,max_position);
  clutchServo.write(servoPosition);
  systemArmed=true;
  overridePending=false;
  overrideLatched=false;
  overrideTripLatched=false;
  pidFirstCompute=true;
  pidIntegral=0.0;
  pidLastError=0.0;
  applyPidFloorLimitsWhileArmed();
  pidOutput=constrain(pidStartPosition,(double)pidFloorRawLo,(double)pidFloorRawHi);
  applyTelemetryPolicy();
  if(telemetryEnabled)lastTelemetryTime=0;
  startLogging();
  bleTxSuppressed=true;
  ioPrintln(String("System ARMED | prehold=")+(pidPreholdEnabled?"ON":"OFF"));
  return true;
}

bool attemptArmFromSwitch(){
  if(overrideLatched){overrideLatched=false;ioPrintln("OVERRIDE CLEARED: ARM SWITCH re-arm.");}
  return attemptArm();
}

void disarmSystem(const String &reason, bool overrideTrip){
  systemArmed=false;
  overridePending=false;
  applyPidFloorLimitsWhileArmed();
  applyTelemetryPolicy();
  stopLogging();
  bleTxSuppressed=false;
  bleTxQueue.clear();
  if(overrideTrip){
    overrideTripLatched=true;
    overrideCooldownUntil=millis()+overrideCooldownMs;
  }
  ioPrintln(reason);
}

void updateOutputs(){
  if(overrideLatched){
    if(millis()-lastLEDFlash>=ledFlashIntervalOverride){
      ledState=!ledState;
      digitalWrite(armLightPin,ledState);
      lastLEDFlash=millis();
    }
    return;
  }
  if(systemArmed){digitalWrite(armLightPin,HIGH);return;}
  if(millis()-lastLEDFlash>=ledFlashInterval){
    ledState=!ledState;
    digitalWrite(armLightPin,ledState);
    lastLEDFlash=millis();
  }
}

int applyCalibration(int position){
  position=constrain(position,min_position,max_position);
  if(direction_reversed)position=max_position-(position-min_position);
  return position;
}

bool processCalibrationCommand(String command){
  command.trim();command.toLowerCase();
  if(command.startsWith("set_min ")){
    int value=command.substring(8).toInt();
    if(value>=0&&value<max_position){
      min_position=value;
      if(neutral_position<min_position)neutral_position=min_position;
      pidStartPosition=constrain(pidStartPosition,min_position,max_position);
      applyPidFloorLimitsWhileArmed();
      servoPosition=constrain(applyCalibration(min_position),min_position,max_position);
      clutchServo.write(servoPosition);
      settingsDirty=true;
      ioPrintln("ok=cal_set_min");
      return true;
    }
    ioPrintln("err=cal_set_min");
    return false;
  }
  else if(command.startsWith("set_max ")){
    int value=command.substring(8).toInt();
    if(value>min_position&&value<=180){
      max_position=value;
      if(neutral_position>max_position)neutral_position=max_position;
      pidStartPosition=constrain(pidStartPosition,min_position,max_position);
      applyPidFloorLimitsWhileArmed();
      servoPosition=constrain(applyCalibration(max_position),min_position,max_position);
      clutchServo.write(servoPosition);
      settingsDirty=true;
      ioPrintln("ok=cal_set_max");
      return true;
    }
    ioPrintln("err=cal_set_max");
    return false;
  }
  else if(command.startsWith("set_neutral ")){
    int value=command.substring(12).toInt();
    if(value>=min_position&&value<=max_position){
      neutral_position=value;
      servoPosition=constrain(applyCalibration(neutral_position),min_position,max_position);
      clutchServo.write(servoPosition);
      settingsDirty=true;
      ioPrintln("ok=cal_set_neutral");
      return true;
    }
    ioPrintln("err=cal_set_neutral");
    return false;
  }
  else if(command.startsWith("direction ")){
    int value=command.substring(10).toInt();
    if(value==0||value==1){
      direction_reversed=(value==1);
      applyPidFloorLimitsWhileArmed();
      servoPosition=constrain(applyCalibration(servoPosition),min_position,max_position);
      clutchServo.write(servoPosition);
      settingsDirty=true;
      ioPrintln("ok=cal_direction");
      return true;
    }
    ioPrintln("err=cal_direction");
    return false;
  }
  else if(command.startsWith("pot_min ")){
    int value=command.substring(8).toInt();
    if(value>=0&&value<manualPotMax){manualPotMin=value;settingsDirty=true;ioPrintln("ok=cal_pot_min");return true;}
    ioPrintln("err=cal_pot_min");
    return false;
  }
  else if(command.startsWith("pot_max ")){
    int value=command.substring(8).toInt();
    if(value>manualPotMin&&value<=4095){manualPotMax=value;settingsDirty=true;ioPrintln("ok=cal_pot_max");return true;}
    ioPrintln("err=cal_pot_max");
    return false;
  }
  ioPrintln("err=unknown_cal");
  return false;
}

bool processSafetyCommand(String command){
  command.trim();command.toLowerCase();
  if(command=="enable"){overrideEnabled=true;settingsDirty=true;ioPrintln("ok=safety_enable");return true;}
  else if(command=="disable"){overrideEnabled=false;overridePending=false;overrideLatched=false;settingsDirty=true;ioPrintln("ok=safety_disable");return true;}
  else if(command.startsWith("set_threshold_pct ")){
    int pct=command.substring(18).toInt();
    if(!setOverrideThresholdPct(pct)){ioPrintln("err=bad_thr_pct");return false;}
    ioPrintln("ok=thr_pct");
    return true;
  }
  else if(command.startsWith("set_threshold ")){
    int adc=command.substring(14).toInt();
    if(adc<manualPotMin||adc>manualPotMax){ioPrintln("err=bad_thr_adc");return false;}
    setOverrideThresholdAdcLegacy(adc);ioPrintln("ok=thr_adc");
    return true;
  }
  else if(command.startsWith("sense ")){
    String v=command.substring(6);v.trim();
    if(v=="normal"){setOverrideSenseReversed(false);ioPrintln("ok=sense");return true;}
    else if(v=="reversed"||v=="reverse"){setOverrideSenseReversed(true);ioPrintln("ok=sense");return true;}
    ioPrintln("err=usage_sense");
    return false;
  }
  ioPrintln("err=unknown_safety");
  return false;
}

void processCommand(String command){
  command.trim();
  if(!command.length())return;
  String lower=command;
  lower.toLowerCase();
  bool ok=true;

  if(lower=="getall"){emitGetAll();}
  else if(lower.startsWith("get ")){
    String key=command.substring(4);
    key.trim();
    ok=emitGetKey(key);
    if(!ok)ioPrintln("err=unknown_key");
  }
  else if(lower.startsWith("log ")){
    String arg=lower.substring(4);
    arg.trim();
    if(arg=="list"){listLogFiles();}
    else if(arg.startsWith("read ")){requestLogRead(arg.substring(5));}
    else if(arg=="cancel"){cancelLogRead();}
    else{ioPrintln("err=usage_log");ok=false;}
  }
  else if(lower.startsWith("prehold ")){
    String arg=lower.substring(8);arg.trim();
    if(systemArmed){ioPrintln("err=prehold_armed");ok=false;}
    else if(arg=="on"){pidPreholdEnabled=true;settingsDirty=true;ioPrintln("ok=prehold_on");}
    else if(arg=="off"){pidPreholdEnabled=false;settingsDirty=true;ioPrintln("ok=prehold_off");}
    else{ioPrintln("err=usage_prehold");ok=false;}
  }
  else if(lower=="prehold"){ioPrintln(String("prehold=")+(pidPreholdEnabled?"1":"0"));}
  else if(lower.startsWith("setrpm ")){
    double newSetpoint=lower.substring(7).toDouble();
    if(newSetpoint>0&&newSetpoint<=100000){setpointRPM=newSetpoint;settingsDirty=true;ioPrintln("ok=setrpm");}
    else{ioPrintln("err=bad_rpm");ok=false;}
  }
  else if(lower.startsWith("setpid ")){
    int firstSpace=lower.indexOf(' ',7);
    int secondSpace=lower.indexOf(' ',firstSpace+1);
    if(firstSpace>0&&secondSpace>0){
      double newKp=lower.substring(7,firstSpace).toDouble();
      double newKi=lower.substring(firstSpace+1,secondSpace).toDouble();
      double newKd=lower.substring(secondSpace+1).toDouble();
      if(newKp>=0&&newKi>=0&&newKd>=0){
        Kp=newKp;Ki=newKi;Kd=newKd;
        settingsDirty=true;
        ioPrintln("ok=setpid");
      }else{ioPrintln("err=bad_pid");ok=false;}
    }else{ioPrintln("err=usage_setpid");ok=false;}
  }
  else if(lower.startsWith("piddir ")){
    String arg=lower.substring(7);arg.trim();
    if(arg=="direct")ok=setPidDirectionSetting(PID_DIR_DIRECT);
    else if(arg=="reverse"||arg=="reversed")ok=setPidDirectionSetting(PID_DIR_REVERSE);
    else{ioPrintln("err=usage_piddir");ok=false;}
  }
  else if(lower.startsWith("aggressiveness ")){
    double value=lower.substring(15).toDouble();
    if(value>=0.1&&value<=3.0){pidAggressiveness=value;settingsDirty=true;ioPrintln("ok=aggr");}
    else{ioPrintln("err=bad_aggr");ok=false;}
  }
  else if(lower.startsWith("setstart ")){
    int v=lower.substring(9).toInt();
    if(v<min_position||v>max_position){ioPrintln("err=bad_setstart");ok=false;}
    else{pidStartPosition=v;settingsDirty=true;applyPidFloorLimitsWhileArmed();ioPrintln("ok=setstart");}
  }
  else if(lower.startsWith("setsample ")){
    ioPrintln("err=sample_fixed_3ms");
    ok=false;
  }
  else if(lower.startsWith("setalpha ")){
    double a=lower.substring(9).toDouble();
    if(a<0.10||a>0.50){ioPrintln("err=bad_alpha");ok=false;}
    else{rpmFilterAlpha=a;settingsDirty=true;ioPrintln("ok=setalpha");}
  }
  else if(lower.startsWith("ppr ")){
    int newPPR=lower.substring(4).toInt();
    if(!(newPPR==1||newPPR==2||newPPR==4)){ioPrintln("err=bad_ppr");ok=false;}
    else{
      int oldPPR=pulsesPerRevolution;
      setpointRPM=setpointRPM*((double)oldPPR/(double)newPPR);
      pulsesPerRevolution=newPPR;
      settingsDirty=true;
      ioPrintln("ok=ppr");
    }
  }
  else if(lower.startsWith("telemetry ")){
    String arg=lower.substring(10);arg.trim();
    if(arg=="auto"){telemetryMode=TELE_AUTO;settingsDirty=true;applyTelemetryPolicy();if(telemetryEnabled)lastTelemetryTime=0;ioPrintln("ok=telemetry");}
    else if(arg=="on"){telemetryMode=TELE_ON;settingsDirty=true;applyTelemetryPolicy();lastTelemetryTime=0;ioPrintln("ok=telemetry");}
    else if(arg=="off"){telemetryMode=TELE_OFF;settingsDirty=true;applyTelemetryPolicy();ioPrintln("ok=telemetry");}
    else if(arg.startsWith("rate ")){
      unsigned long ms=(unsigned long)arg.substring(5).toInt();
      if(ms<telemetryRateMinMs||ms>telemetryRateMaxMs){ioPrintln("err=bad_telrate");ok=false;}
      else{telemetryIntervalMs=ms;settingsDirty=true;if(telemetryEnabled)lastTelemetryTime=0;ioPrintln("ok=telrate");}
    }else{ioPrintln("err=usage_telemetry");ok=false;}
  }
  else if(lower.startsWith("safety ")){ok=processSafetyCommand(lower.substring(7));}
  else if(lower.startsWith("calibrate ")){ok=processCalibrationCommand(lower.substring(10));}
  else if(lower=="save"){saveCalibrationData();settingsDirty=false;ioPrintln("ok=save");}
  else if(lower=="dirty")ioPrintln(String("dirty=")+(settingsDirty?"1":"0"));
  else if(lower=="arm"){if(overrideLatched){ioPrintln("err=override_latched");ok=false;}else ok=attemptArm();}
  else if(lower=="disarm")disarmSystem("System DISARMED (command)");
  else if(lower=="status")printDetailedStatus();
  else if(lower=="help")printHelp();
  else{ioPrintln("err=unknown_cmd");ok=false;}

  sendAck(command, ok);
}

void processInput(){
  static bool inputOverflow=false;
  while(Serial.available()){
    char inChar=(char)Serial.read();
    if(inChar=='\r')continue;
    if(inputOverflow){
      if(inChar=='\n'){inputOverflow=false; inputString=""; stringComplete=false;}
      continue;
    }
    if(inChar=='\n')stringComplete=true;
    else{
      if(inputString.length()<200) inputString+=inChar;
      else{
        inputOverflow=true;
        inputString="";
        ioPrintln("err=input_overflow");
      }
    }
  }
  if(stringComplete){
    inputString.trim();
    if(inputString.length())processCommand(inputString);
    inputString="";
    stringComplete=false;
  }
}

void printDetailedStatus(){
  uint32_t cooldownRemaining=(overrideCooldownUntil>millis())?(overrideCooldownUntil-millis()):0;
  ioPrintln("=== STATUS ===");
  ioPrintln("RPM: "+String(currentRPM));
  ioPrintln("Target: "+String(setpointRPM));
  ioPrintln("Servo: "+String(servoPosition));
  ioPrintln("Mode: "+modeString());
  ioPrintln("PID Out: "+String(pidOutput));
  ioPrintln("PID Dir: "+String(pidDirToString(pidDirectionSetting)));
  ioPrintln("Gains: Kp="+String(Kp,4)+" Ki="+String(Ki,4)+" Kd="+String(Kd,4));
  ioPrintln("Aggr: "+String(pidAggressiveness,2));
  ioPrintln("Start: "+String(pidStartPosition));
  ioPrintln("Prehold: "+String(pidPreholdEnabled?"ON":"OFF"));
  ioPrintln("PPR: "+String(pulsesPerRevolution));
  ioPrintln("Sample: "+String(pidSampleTimeMs)+" ms");
  ioPrintln("Alpha: "+String(rpmFilterAlpha,2));
  ioPrintln("Tele: "+String(telemetryModeToString(telemetryMode))+" @ "+String(telemetryIntervalMs)+" ms");
  ioPrintln("Safety: "+String(overrideEnabled?"EN":"DIS")+" thr="+String(overrideThresholdPct)+"% sense="+String(overrideSenseReversed?"REV":"NOR"));
  ioPrintln("Pending: "+String(overridePending?"YES":"NO")+" | Latched: "+String(overrideLatched?"YES":"NO"));
  ioPrintln("Override Trip: "+String(overrideTripLatched?"YES":"NO")+" | Cooldown: "+String(cooldownRemaining)+" ms");
  ioPrintln("Floor: lo="+String(pidFloorRawLo)+" hi="+String(pidFloorRawHi));
  ioPrintln("Dirty: "+String(settingsDirty?"YES":"NO"));
  ioPrintln("BLE: "+String(bleConnected?"CONN":"DISC"));
  ioPrintln("Queue: "+String(bleTxQueue.available())+"/"+String(BLE_TX_QUEUE_SIZE));
  ioPrintln("Log dropped: "+String((unsigned long)logDropped));
  ioPrintln("==============");
}

void printHelp(){
  ioPrintln("Commands:");
  ioPrintln("  getall | get <key>");
  ioPrintln("  log list | log read <file> | log cancel");
  ioPrintln("  setrpm <rpm> | setpid <kp> <ki> <kd>");
  ioPrintln("  piddir direct|reverse");
  ioPrintln("  aggressiveness <0.1-3.0>");
  ioPrintln("  setstart <deg> | prehold on|off");
  ioPrintln("  setsample <fixed 3ms> | setalpha <0.10-0.50>");
  ioPrintln("  ppr <1|2|4>");
  ioPrintln("  telemetry auto|on|off | telemetry rate <ms>");
  ioPrintln("  calibrate set_min|set_max|set_neutral <val>");
  ioPrintln("  calibrate direction <0|1>");
  ioPrintln("  calibrate pot_min|pot_max <val>");
  ioPrintln("  safety enable|disable");
  ioPrintln("  safety set_threshold_pct <0-100>");
  ioPrintln("  safety sense normal|reversed");
  ioPrintln("  save | dirty | arm | disarm | status | help");
}

void printCalibrationStatus(){
  ioPrintln("=== Calibration ===");
  ioPrintln("Servo: Min="+String(min_position)+" Max="+String(max_position)+" Neutral="+String(neutral_position));
  ioPrintln("Direction: "+String(direction_reversed?"REVERSED":"NORMAL"));
  ioPrintln("Start: "+String(pidStartPosition)+" | Prehold: "+String(pidPreholdEnabled?"ON":"OFF"));
  ioPrintln("Pot: Min="+String(manualPotMin)+" Max="+String(manualPotMax));
  ioPrintln("Safety: "+String(overrideEnabled?"EN":"DIS")+" thr="+String(overrideThresholdPct)+"% sense="+String(overrideSenseReversed?"REV":"NOR"));
  ioPrintln("PID Dir: "+String(pidDirToString(pidDirectionSetting)));
  ioPrintln("===================");
}

void saveCalibrationData(){
  preferences.begin("emc_calibration",false);
  preferences.putInt("min_pos",min_position);
  preferences.putInt("max_pos",max_position);
  preferences.putInt("neutral_pos",neutral_position);
  preferences.putBool("direction",direction_reversed);
  preferences.putInt("pot_min",manualPotMin);
  preferences.putInt("pot_max",manualPotMax);
  preferences.putInt("override_thresh",pctToAdcForOverride(overrideThresholdPct));
  preferences.putBool("override_en",overrideEnabled);
  preferences.putInt("ov_thr_pct",overrideThresholdPct);
  preferences.putBool("ov_sense_rev",overrideSenseReversed);
  preferences.putInt("ppr",pulsesPerRevolution);
  preferences.putInt("pid_ts",pidSampleTimeMs);
  preferences.putInt("rpm_alpha_x100",(int)lround(rpmFilterAlpha*100.0));
  preferences.putInt("start_pos",pidStartPosition);
  preferences.putBool("prehold",pidPreholdEnabled);
  preferences.putDouble("setpoint",setpointRPM);
  preferences.putDouble("kp",Kp);
  preferences.putDouble("ki",Ki);
  preferences.putDouble("kd",Kd);
  preferences.putDouble("aggr",pidAggressiveness);
  preferences.putInt("pid_dir",(int)pidDirectionSetting);
  preferences.putInt("tele_mode",(int)telemetryMode);
  preferences.putInt("tele_ms",(int)telemetryIntervalMs);
  preferences.end();
  ioPrintln("Saved ALL settings to NVS.");
}

void loadCalibrationData(){
  preferences.begin("emc_calibration",false);
  min_position=preferences.getInt("min_pos",0);
  max_position=preferences.getInt("max_pos",180);
  neutral_position=preferences.getInt("neutral_pos",90);
  direction_reversed=preferences.getBool("direction",false);
  manualPotMin=preferences.getInt("pot_min",0);
  manualPotMax=preferences.getInt("pot_max",4095);
  if(manualPotMin>=manualPotMax)manualPotMin=0;
  overrideEnabled=preferences.getBool("override_en",false);
  overrideSenseReversed=preferences.getBool("ov_sense_rev",false);
  pidPreholdEnabled=preferences.getBool("prehold",true);
  int loadedPct=preferences.getInt("ov_thr_pct",-1);
  if(loadedPct>=0&&loadedPct<=100){
    overrideThresholdPct=loadedPct;
  }else{
    int legacyAdc=preferences.getInt("override_thresh",(int)(manualPotMax*0.85));
    legacyAdc=constrain(legacyAdc,manualPotMin,manualPotMax);
    overrideThresholdPct=adcToPctForOverride(legacyAdc);
  }
  int loadedPPR=preferences.getInt("ppr",1);
  pulsesPerRevolution=(loadedPPR==1||loadedPPR==2||loadedPPR==4)?loadedPPR:1;
  (void)loadedPPR;
  pidSampleTimeMs=3; // fixed regardless of saved value
  int alphaX100=preferences.getInt("rpm_alpha_x100",30);
  double loadedAlpha=alphaX100/100.0;
  rpmFilterAlpha=constrain(loadedAlpha,0.10,0.50);
  pidStartPosition=preferences.getInt("start_pos",pidStartPosition);
  pidStartPosition=constrain(pidStartPosition,min_position,max_position);
  double loadedSetpoint=preferences.getDouble("setpoint",setpointRPM);
  if(loadedSetpoint>0&&loadedSetpoint<=100000)setpointRPM=loadedSetpoint;
  double loadedKp=preferences.getDouble("kp",Kp);
  double loadedKi=preferences.getDouble("ki",Ki);
  double loadedKd=preferences.getDouble("kd",Kd);
  if(loadedKp>=0)Kp=loadedKp;
  if(loadedKi>=0)Ki=loadedKi;
  if(loadedKd>=0)Kd=loadedKd;
  double loadedAggr=preferences.getDouble("aggr",pidAggressiveness);
  if(loadedAggr>=0.1&&loadedAggr<=3.0)pidAggressiveness=loadedAggr;
  int loadedPidDir=preferences.getInt("pid_dir",(int)PID_DIR_DIRECT);
  if(loadedPidDir!=(int)PID_DIR_DIRECT&&loadedPidDir!=(int)PID_DIR_REVERSE)loadedPidDir=(int)PID_DIR_DIRECT;
  pidDirectionSetting=(PidDirectionSetting)loadedPidDir;
  int loadedTeleMode=preferences.getInt("tele_mode",(int)TELE_AUTO);
  if(loadedTeleMode<0||loadedTeleMode>2)loadedTeleMode=(int)TELE_AUTO;
  telemetryMode=(TelemetryMode)loadedTeleMode;
  int loadedTeleMs=preferences.getInt("tele_ms",500);
  if(loadedTeleMs<(int)telemetryRateMinMs)loadedTeleMs=telemetryRateMinMs;
  if(loadedTeleMs>(int)telemetryRateMaxMs)loadedTeleMs=telemetryRateMaxMs;
  telemetryIntervalMs=(unsigned long)loadedTeleMs;
  preferences.end();
  Serial.println("Calibration loaded from NVS.");
}

