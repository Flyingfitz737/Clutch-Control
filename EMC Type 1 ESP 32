#include <Arduino.h>
#include <PID_v1.h>
#include <ESP32Servo.h>  // ESP32-specific servo library
#include "BluetoothSerial.h"  // Bluetooth Classic library

// ===== EMC Type 1 Controller for ESP32 =====
// Hydraulic clutch controller with user-defined parameters,
// automatic sensor inputs, PID control, LED feedback, and Bluetooth Classic communication
//
// Required Libraries for ESP32:
// - PID_v1 (Arduino IDE Library Manager)
// - ESP32Servo (Arduino IDE Library Manager)
// - BluetoothSerial (included with ESP32 Core)
//
// Hardware Requirements:
// - ESP32 development board
// - RPM sensor connected to GPIO19
// - Potentiometers connected to GPIO34 and GPIO35
// - Servo motor connected to GPIO18
// - Arm switch connected to GPIO21
// - LED connected to GPIO2 (or use built-in LED)
//
// Bluetooth Features:
// - Device name: "EMC_Type_1_Controller"
// - Supports all serial commands: setrpm, setpid, arm, disarm, status, help
// - Real-time status feedback over Bluetooth

// ===== Pin Definitions =====
const int rpmSensorPin = 19;        // Digital pin for RPM sensor pulse train (interrupt capable)
const int potentiometerPin = 34;    // Analog input for additional potentiometer (ADC1_CH6)
const int manualPotPin = 35;        // Analog input for manual servo control potentiometer (ADC1_CH7)
const int servoPin = 18;            // PWM pin for servo motor control
const int armLightPin = 2;          // LED pin for arming light (built-in LED on ESP32)
const int armSwitchPin = 21;        // Digital pin for arm switch


// ===== Global Variables =====
// RPM pulse counting variables (volatile for ISR)
volatile unsigned long pulseCount = 0;
volatile unsigned long lastPulseTime = 0;
unsigned long lastRPMCalculation = 0;
const unsigned long rpmCalculationInterval = 1000; // Calculate RPM every 1000ms
const int pulsesPerRevolution = 1; // Assuming 1 pulse per revolution for ECU signal

// Sensor readings
int potValue = 0;
int manualPotValue = 0;
bool armSwitch = false;

bool systemArmed = false;

// LED flashing variables for manual mode
unsigned long lastLEDFlash = 0;
const unsigned long ledFlashInterval = 500; // Flash every 500ms
bool ledState = false;

// PID Control Variables
double setpointRPM = 1000.0;        // Target RPM (user-configurable)
double currentRPM = 0.0;            // Current RPM from sensor
double pidOutput = 0.0;             // PID output (0-255 for PWM)
double Kp = 2.0, Ki = 5.0, Kd = 1.0; // PID constants (user-configurable)

// Servo control
Servo clutchServo;
int servoPosition = 90;             // Servo position (0-180 degrees)

// PID Controller
PID myPID(&currentRPM, &pidOutput, &setpointRPM, Kp, Ki, Kd, DIRECT);

// Serial communication variables
String inputString = "";
bool stringComplete = false;

// Bluetooth communication variables
BluetoothSerial SerialBT;
String btInputString = "";
bool btStringComplete = false;

// Timing variables
unsigned long lastPrintTime = 0;
const unsigned long printInterval = 500; // Print status every 500ms

// ===== Setup Function =====
void setup() {
  Serial.begin(115200); // Higher baud rate for ESP32
  
  // Initialize Bluetooth Classic
  SerialBT.begin("EMC_Type_1_Controller"); // Bluetooth device name
  Serial.println("Bluetooth initialized. Device name: EMC_Type_1_Controller");
  
  // Initialize pin modes
  pinMode(rpmSensorPin, INPUT_PULLUP); // Digital input with pullup for RPM pulse train
  pinMode(potentiometerPin, INPUT);
  pinMode(manualPotPin, INPUT);
  pinMode(armLightPin, OUTPUT);
  pinMode(armSwitchPin, INPUT_PULLUP);

  // Configure ADC resolution for ESP32 (12-bit by default)
  analogReadResolution(12); // ESP32 supports 12-bit ADC (0-4095)

  // Setup interrupt for RPM pulse counting (falling edge detection)
  attachInterrupt(digitalPinToInterrupt(rpmSensorPin), rpmPulseISR, FALLING);
  
  // Initialize timing variables
  lastRPMCalculation = millis();
  
  // Initialize servo
  clutchServo.attach(servoPin);
  clutchServo.write(servoPosition);
  
  // Initialize PID controller
  myPID.SetMode(AUTOMATIC);
  myPID.SetOutputLimits(0, 180); // Servo range 0-180 degrees
  
  // Initialize outputs
  digitalWrite(armLightPin, LOW);
  
  // Reserve string space for serial input
  inputString.reserve(200);
  btInputString.reserve(200);
  
  // Print startup message
  Serial.println("=== EMC Type 1 Controller Initialized (ESP32) ===");
  Serial.println("Bluetooth Device Name: EMC_Type_1_Controller");
  Serial.println("RPM Input: Digital pulse train on pin 19 (interrupt)");
  Serial.println("Manual Control: Potentiometer on pin 35");
  Serial.println("Commands (via Serial or Bluetooth):");
  Serial.println("  setrpm <value>     - Set target RPM");
  Serial.println("  setpid <kp> <ki> <kd> - Set PID constants");
  Serial.println("  arm                - Arm the system (automatic mode)");
  Serial.println("  disarm             - Disarm the system (manual mode)");
  Serial.println("  status             - Show current status");
  Serial.println("  help               - Show this help");
  Serial.println("========================================");
  printStatus();
}

// ===== Bluetooth Helper Functions =====
void dualPrint(String message) {
  Serial.print(message);
  SerialBT.print(message);
}

void dualPrintln(String message) {
  Serial.println(message);
  SerialBT.println(message);
}

void dualPrintln() {
  Serial.println();
  SerialBT.println();
}

// ===== Main Loop =====
void loop() {
  // Read sensor inputs
  readSensors();
  
  // Process serial and Bluetooth commands
  processInput();
  
  // Update system state
  updateSystemState();
  
  // Run PID control if armed (automatic mode)
  if (systemArmed) {
    runPIDControl();
  } else {
    // Manual servo control when disarmed
    runManualControl();
  }
  
  // Update outputs
  updateOutputs();
  
  // Print status periodically
  if (millis() - lastPrintTime >= printInterval) {
    printStatus();
    lastPrintTime = millis();
  }
  
  delay(50); // Small delay for stability
}

// ===== Function Implementations =====

// Interrupt Service Routine for RPM pulse counting
void rpmPulseISR() {
  pulseCount++;
  lastPulseTime = micros();
}

void readSensors() {
  // Calculate RPM from pulse count over time interval
  unsigned long currentTime = millis();
  
  if (currentTime - lastRPMCalculation >= rpmCalculationInterval) {
    // Calculate RPM: (pulses * 60 seconds) / (time_interval_in_seconds * pulses_per_revolution)
    unsigned long timeDelta = currentTime - lastRPMCalculation;
    
    noInterrupts(); // Disable interrupts while reading volatile variables
    unsigned long currentPulseCount = pulseCount;
    pulseCount = 0; // Reset pulse count for next interval
    interrupts(); // Re-enable interrupts
    
    // Calculate RPM
    if (timeDelta > 0) {
      currentRPM = (currentPulseCount * 60000.0) / (timeDelta * pulsesPerRevolution);
    }
    
    lastRPMCalculation = currentTime;
  }
  
  // Read potentiometer
  potValue = analogRead(potentiometerPin);
  
  // Read manual control potentiometer
  manualPotValue = analogRead(manualPotPin);
  
  // Read digital switches (active LOW with pullup)
  armSwitch = !digitalRead(armSwitchPin);

}

void processInput() {
  // Check for serial input
  while (Serial.available()) {
    char inChar = (char)Serial.read();
    
    if (inChar == '\n') {
      stringComplete = true;
    } else {
      inputString += inChar;
    }
  }
  
  // Check for Bluetooth input
  while (SerialBT.available()) {
    char inChar = (char)SerialBT.read();
    
    if (inChar == '\n') {
      btStringComplete = true;
    } else {
      btInputString += inChar;
    }
  }
  
  // Process complete serial command
  if (stringComplete) {
    processCommand(inputString);
    inputString = "";
    stringComplete = false;
  }
  
  // Process complete Bluetooth command
  if (btStringComplete) {
    processCommand(btInputString);
    btInputString = "";
    btStringComplete = false;
  }
}

void processCommand(String command) {
  command.trim();
  command.toLowerCase();
  
  if (command.startsWith("setrpm ")) {
    double newSetpoint = command.substring(7).toDouble();
    if (newSetpoint > 0 && newSetpoint <= 10000) {
      setpointRPM = newSetpoint;
      dualPrintln("Target RPM set to: " + String(setpointRPM));
    } else {
      dualPrintln("Invalid RPM value. Range: 1-10000");
    }
  }
  else if (command.startsWith("setpid ")) {
    // Parse PID values: setpid kp ki kd
    int firstSpace = command.indexOf(' ', 7);
    int secondSpace = command.indexOf(' ', firstSpace + 1);
    
    if (firstSpace > 0 && secondSpace > 0) {
      double newKp = command.substring(7, firstSpace).toDouble();
      double newKi = command.substring(firstSpace + 1, secondSpace).toDouble();
      double newKd = command.substring(secondSpace + 1).toDouble();
      
      if (newKp >= 0 && newKi >= 0 && newKd >= 0) {
        Kp = newKp;
        Ki = newKi;
        Kd = newKd;
        myPID.SetTunings(Kp, Ki, Kd);
        dualPrintln("PID constants updated:");
        dualPrintln("  Kp: " + String(Kp));
        dualPrintln("  Ki: " + String(Ki));
        dualPrintln("  Kd: " + String(Kd));
      } else {
        dualPrintln("Invalid PID values. Must be non-negative.");
      }
    } else {
      dualPrintln("Usage: setpid <kp> <ki> <kd>");
    }
  }
  else if (command == "arm") {
    systemArmed = true;
    dualPrintln("System ARMED - Automatic PID Control Mode");
  }
  else if (command == "disarm") {
    systemArmed = false;
    dualPrintln("System DISARMED - Manual Control Mode");
  }
  else if (command == "status") {
    printDetailedStatus();
  }
  else if (command == "help") {
    printHelp();
  }
  else {
    dualPrintln("Unknown command: " + command);
    dualPrintln("Type 'help' for available commands.");
  }
}

void updateSystemState() {
  // System is armed if either arm switch is pressed OR armed via serial
  bool shouldBeArmed = systemArmed || armSwitch;
  
  if (shouldBeArmed && !systemArmed) {
    systemArmed = true;
    dualPrintln("System ARMED via switch - Automatic PID Control Mode");
  } else if (!shouldBeArmed && systemArmed && !armSwitch) {
    // Only disarm if switch is released and not armed via serial
    systemArmed = false;
    dualPrintln("System DISARMED via switch - Manual Control Mode");
  }
}

void runPIDControl() {
  // Compute PID output
  if (myPID.Compute()) {
    // Map PID output to servo position
    servoPosition = (int)pidOutput;
    servoPosition = constrain(servoPosition, 0, 180);
    clutchServo.write(servoPosition);
  }
}

void runManualControl() {
  // Map potentiometer value (0-4095 for ESP32 12-bit ADC) to servo position (0-180 degrees)
  servoPosition = map(manualPotValue, 0, 4095, 0, 180);
  servoPosition = constrain(servoPosition, 0, 180);
  clutchServo.write(servoPosition);
}

void updateOutputs() {
  // Update arm light - solid on when armed (automatic), flashing when disarmed (manual)
  if (systemArmed) {
    // Solid on when armed (automatic mode)
    digitalWrite(armLightPin, HIGH);
  } else {
    // Flashing when disarmed (manual mode)
    unsigned long currentTime = millis();
    if (currentTime - lastLEDFlash >= ledFlashInterval) {
      ledState = !ledState;
      digitalWrite(armLightPin, ledState);
      lastLEDFlash = currentTime;
    }
  }
}

void printStatus() {
  dualPrint("RPM: ");
  dualPrint(String(currentRPM));
  dualPrint(" | Target: ");
  dualPrint(String(setpointRPM));
  dualPrint(" | Servo: ");
  dualPrint(String(servoPosition));
  dualPrint("° | Mode: ");
  dualPrint(systemArmed ? "AUTO" : "MANUAL");
  dualPrint(" | PID Out: ");
  dualPrintln(String(pidOutput));
}

void printDetailedStatus() {
  dualPrintln("=== EMC Type 1 Controller Status ===");
  dualPrintln("Sensor Readings:");
  
  // Show pulse count and frequency information
  noInterrupts();
  unsigned long currentPulseCount = pulseCount;
  interrupts();
  
  dualPrintln("  RPM Sensor: Digital pulse train on pin 19");
  dualPrintln("  Current RPM: " + String(currentRPM));
  dualPrintln("  Pulse Count (current interval): " + String(currentPulseCount));
  dualPrintln("  Potentiometer: " + String(potValue));
  dualPrintln("  Manual Control Pot: " + String(manualPotValue));
  dualPrintln("  Arm Switch: " + String(armSwitch ? "PRESSED" : "RELEASED"));

  dualPrintln();
  
  dualPrintln("Control Parameters:");
  dualPrintln("  Target RPM: " + String(setpointRPM));
  dualPrintln("  PID Kp: " + String(Kp));
  dualPrintln("  PID Ki: " + String(Ki));
  dualPrintln("  PID Kd: " + String(Kd));
  dualPrintln();
  
  dualPrintln("System State:");
  dualPrintln("  Mode: " + String(systemArmed ? "AUTOMATIC" : "MANUAL"));
  dualPrintln("  Armed: " + String(systemArmed ? "YES" : "NO"));
  dualPrintln("  Servo Position: " + String(servoPosition) + "°");
  dualPrintln("  PID Output: " + String(pidOutput));
  dualPrintln("  Arm Light: " + String(digitalRead(armLightPin) ? "ON" : "OFF"));
  dualPrintln("====================================");
}

void printHelp() {
  dualPrintln("=== EMC Type 1 Controller Commands ===");
  dualPrintln("setrpm <value>     - Set target RPM (1-10000)");
  dualPrintln("setpid <kp> <ki> <kd> - Set PID constants");
  dualPrintln("arm                - Arm system (automatic PID mode)");
  dualPrintln("disarm             - Disarm system (manual control mode)");
  dualPrintln("status             - Show detailed status");
  dualPrintln("help               - Show this help");
  dualPrintln("");
  dualPrintln("MODES:");
  dualPrintln("  AUTOMATIC: System armed, PID controls servo");
  dualPrintln("  MANUAL: System disarmed, pin 35 potentiometer controls servo");
  dualPrintln("=======================================");
}