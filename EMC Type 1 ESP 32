#include <Arduino.h>
#include <PID_v1.h>
#include <ESP32Servo.h>  // ESP32-specific servo library
#include "BluetoothSerial.h"  // Bluetooth Classic library
#include <EEPROM.h>  // For persistent calibration storage

// ===== EMC Type 1 Controller for ESP32 =====
// Hydraulic clutch controller with user-defined parameters,
// automatic sensor inputs, PID control, LED feedback, and Bluetooth Classic communication
//
// Required Libraries for ESP32:
// - PID_v1 (Arduino IDE Library Manager)
// - ESP32Servo (Arduino IDE Library Manager)
// - BluetoothSerial (included with ESP32 Core)
//
// Hardware Requirements:
// - ESP32 development board
// - RPM sensor connected to GPIO19
// - Potentiometers connected to GPIO34 and GPIO35
// - Servo motor connected to GPIO18
// - Arm switch connected to GPIO21
// - LED connected to GPIO2 (or use built-in LED)
//
// Bluetooth Features:
// - Device name: "EMC_Type_1_Controller"
// - Supports all serial commands: setrpm, setpid, arm, disarm, status, help
// - Real-time status feedback over Bluetooth

// ===== Pin Definitions =====
const int rpmSensorPin = 19;        // Digital pin for RPM sensor pulse train (interrupt capable)
const int potentiometerPin = 34;    // Analog input for additional potentiometer (ADC1_CH6)
const int manualPotPin = 35;        // Analog input for manual servo control potentiometer (ADC1_CH7)
const int servoPin = 18;            // PWM pin for servo motor control
const int armLightPin = 2;          // LED pin for arming light (built-in LED on ESP32)
const int armSwitchPin = 21;        // Digital pin for arm switch

// ===== Calibration Data Structure =====
struct CalibrationData {
  int minPosition = 0;      // Minimum servo position (0-180)
  int maxPosition = 180;    // Maximum servo position (0-180)
  int neutralPosition = 90; // Neutral/default servo position (0-180)
  bool direction = true;    // Servo direction: true = normal, false = reversed
  bool isValid = false;     // Flag to indicate if calibration data is valid
};

// EEPROM address for calibration data
const int EEPROM_SIZE = 512;
const int CALIBRATION_ADDR = 0;

// Global calibration data
CalibrationData calibration;


// ===== Global Variables =====
// RPM pulse counting variables (volatile for ISR)
volatile unsigned long pulseCount = 0;
volatile unsigned long lastPulseTime = 0;
unsigned long lastRPMCalculation = 0;
const unsigned long rpmCalculationInterval = 1000; // Calculate RPM every 1000ms
const int pulsesPerRevolution = 1; // Assuming 1 pulse per revolution for ECU signal

// Sensor readings
int potValue = 0;
int manualPotValue = 0;
bool armSwitch = false;

bool systemArmed = false;

// LED flashing variables for manual mode
unsigned long lastLEDFlash = 0;
const unsigned long ledFlashInterval = 500; // Flash every 500ms
bool ledState = false;

// PID Control Variables
double setpointRPM = 1000.0;        // Target RPM (user-configurable)
double currentRPM = 0.0;            // Current RPM from sensor
double pidOutput = 0.0;             // PID output (0-255 for PWM)
double Kp = 2.0, Ki = 5.0, Kd = 1.0; // PID constants (user-configurable)

// Servo control
Servo clutchServo;
int servoPosition = 90;             // Current servo position (0-180 degrees)

// PID Controller
PID myPID(&currentRPM, &pidOutput, &setpointRPM, Kp, Ki, Kd, DIRECT);

// Serial communication variables
String inputString = "";
bool stringComplete = false;

// Bluetooth communication variables
BluetoothSerial SerialBT;
String btInputString = "";
bool btStringComplete = false;

// Timing variables
unsigned long lastPrintTime = 0;
const unsigned long printInterval = 500; // Print status every 500ms

// ===== Setup Function =====
void setup() {
  Serial.begin(115200); // Higher baud rate for ESP32
  
  // Initialize EEPROM
  EEPROM.begin(EEPROM_SIZE);
  
  // Load calibration data from EEPROM
  loadCalibrationData();
  
  // Initialize Bluetooth Classic
  SerialBT.begin("EMC_Type_1_Controller"); // Bluetooth device name
  Serial.println("Bluetooth initialized. Device name: EMC_Type_1_Controller");
  
  // Initialize pin modes
  pinMode(rpmSensorPin, INPUT_PULLUP); // Digital input with pullup for RPM pulse train
  pinMode(potentiometerPin, INPUT);
  pinMode(manualPotPin, INPUT);
  pinMode(armLightPin, OUTPUT);
  pinMode(armSwitchPin, INPUT_PULLUP);

  // Configure ADC resolution for ESP32 (12-bit by default)
  analogReadResolution(12); // ESP32 supports 12-bit ADC (0-4095)

  // Setup interrupt for RPM pulse counting (falling edge detection)
  attachInterrupt(digitalPinToInterrupt(rpmSensorPin), rpmPulseISR, FALLING);
  
  // Initialize timing variables
  lastRPMCalculation = millis();
  
  // Initialize servo with neutral position from calibration
  clutchServo.attach(servoPin);
  servoPosition = calibration.neutralPosition;
  clutchServo.write(servoPosition);
  
  // Initialize PID controller with calibrated output limits
  myPID.SetMode(AUTOMATIC);
  myPID.SetOutputLimits(calibration.minPosition, calibration.maxPosition);
  
  // Initialize outputs
  digitalWrite(armLightPin, LOW);
  
  // Reserve string space for serial input
  inputString.reserve(200);
  btInputString.reserve(200);
  
  // Print startup message
  Serial.println("=== EMC Type 1 Controller Initialized (ESP32) ===");
  Serial.println("Bluetooth Device Name: EMC_Type_1_Controller");
  Serial.println("RPM Input: Digital pulse train on pin 19 (interrupt)");
  Serial.println("Manual Control: Potentiometer on pin 35");
  Serial.println("Commands (via Serial or Bluetooth):");
  Serial.println("  setrpm <value>     - Set target RPM");
  Serial.println("  setpid <kp> <ki> <kd> - Set PID constants");
  Serial.println("  calibrate set_min <value> - Set minimum servo position");
  Serial.println("  calibrate set_max <value> - Set maximum servo position");
  Serial.println("  calibrate set_neutral <value> - Set neutral servo position");
  Serial.println("  calibrate direction <normal|reversed> - Set servo direction");
  Serial.println("  arm                - Arm the system (automatic mode)");
  Serial.println("  disarm             - Disarm the system (manual mode)");
  Serial.println("  status             - Show current status");
  Serial.println("  help               - Show this help");
  Serial.println("========================================");
  printStatus();
}

// ===== Bluetooth Helper Functions =====
void dualPrint(String message) {
  Serial.print(message);
  SerialBT.print(message);
}

void dualPrintln(String message) {
  Serial.println(message);
  SerialBT.println(message);
}

void dualPrintln() {
  Serial.println();
  SerialBT.println();
}

// ===== Main Loop =====
void loop() {
  // Read sensor inputs
  readSensors();
  
  // Process serial and Bluetooth commands
  processInput();
  
  // Update system state
  updateSystemState();
  
  // Run PID control if armed (automatic mode)
  if (systemArmed) {
    runPIDControl();
  } else {
    // Manual servo control when disarmed
    runManualControl();
  }
  
  // Update outputs
  updateOutputs();
  
  // Print status periodically
  if (millis() - lastPrintTime >= printInterval) {
    printStatus();
    lastPrintTime = millis();
  }
  
  delay(50); // Small delay for stability
}

// ===== Function Implementations =====

// ===== Calibration Functions =====
void saveCalibrationData() {
  calibration.isValid = true;
  EEPROM.put(CALIBRATION_ADDR, calibration);
  EEPROM.commit();
  dualPrintln("Calibration data saved to EEPROM");
}

void loadCalibrationData() {
  EEPROM.get(CALIBRATION_ADDR, calibration);
  
  // Check if calibration data is valid, if not use defaults
  if (!calibration.isValid || 
      calibration.minPosition < 0 || calibration.minPosition > 180 ||
      calibration.maxPosition < 0 || calibration.maxPosition > 180 ||
      calibration.neutralPosition < 0 || calibration.neutralPosition > 180 ||
      calibration.minPosition >= calibration.maxPosition) {
    
    // Use default calibration values
    calibration.minPosition = 0;
    calibration.maxPosition = 180;
    calibration.neutralPosition = 90;
    calibration.direction = true;
    calibration.isValid = true;
    
    // Save defaults to EEPROM
    saveCalibrationData();
    Serial.println("Using default calibration values");
  } else {
    Serial.println("Loaded calibration data from EEPROM");
  }
}

int applyCalibration(int position) {
  // Constrain position within calibrated limits
  position = constrain(position, calibration.minPosition, calibration.maxPosition);
  
  // Apply direction reversal if needed
  if (!calibration.direction) {
    // Reverse direction: map position from calibrated range to reversed range
    position = calibration.maxPosition - (position - calibration.minPosition);
  }
  
  return position;
}

void moveServoToPosition(int position) {
  // Apply calibration and move servo
  int calibratedPosition = applyCalibration(position);
  servoPosition = calibratedPosition;
  clutchServo.write(servoPosition);
  
  // Provide real-time feedback
  dualPrintln("Servo moved to position: " + String(position) + "° (calibrated: " + String(calibratedPosition) + "°)");
}

// Interrupt Service Routine for RPM pulse counting
void rpmPulseISR() {
  pulseCount++;
  lastPulseTime = micros();
}

void readSensors() {
  // Calculate RPM from pulse count over time interval
  unsigned long currentTime = millis();
  
  if (currentTime - lastRPMCalculation >= rpmCalculationInterval) {
    // Calculate RPM: (pulses * 60 seconds) / (time_interval_in_seconds * pulses_per_revolution)
    unsigned long timeDelta = currentTime - lastRPMCalculation;
    
    noInterrupts(); // Disable interrupts while reading volatile variables
    unsigned long currentPulseCount = pulseCount;
    pulseCount = 0; // Reset pulse count for next interval
    interrupts(); // Re-enable interrupts
    
    // Calculate RPM
    if (timeDelta > 0) {
      currentRPM = (currentPulseCount * 60000.0) / (timeDelta * pulsesPerRevolution);
    }
    
    lastRPMCalculation = currentTime;
  }
  
  // Read potentiometer
  potValue = analogRead(potentiometerPin);
  
  // Read manual control potentiometer
  manualPotValue = analogRead(manualPotPin);
  
  // Read digital switches (active LOW with pullup)
  armSwitch = !digitalRead(armSwitchPin);

}

void processInput() {
  // Check for serial input
  while (Serial.available()) {
    char inChar = (char)Serial.read();
    
    if (inChar == '\n') {
      stringComplete = true;
    } else {
      inputString += inChar;
    }
  }
  
  // Check for Bluetooth input
  while (SerialBT.available()) {
    char inChar = (char)SerialBT.read();
    
    if (inChar == '\n') {
      btStringComplete = true;
    } else {
      btInputString += inChar;
    }
  }
  
  // Process complete serial command
  if (stringComplete) {
    processCommand(inputString);
    inputString = "";
    stringComplete = false;
  }
  
  // Process complete Bluetooth command
  if (btStringComplete) {
    processCommand(btInputString);
    btInputString = "";
    btStringComplete = false;
  }
}

void processCommand(String command) {
  command.trim();
  command.toLowerCase();
  
  if (command.startsWith("setrpm ")) {
    double newSetpoint = command.substring(7).toDouble();
    if (newSetpoint > 0 && newSetpoint <= 10000) {
      setpointRPM = newSetpoint;
      dualPrintln("Target RPM set to: " + String(setpointRPM));
    } else {
      dualPrintln("Invalid RPM value. Range: 1-10000");
    }
  }
  else if (command.startsWith("setpid ")) {
    // Parse PID values: setpid kp ki kd
    int firstSpace = command.indexOf(' ', 7);
    int secondSpace = command.indexOf(' ', firstSpace + 1);
    
    if (firstSpace > 0 && secondSpace > 0) {
      double newKp = command.substring(7, firstSpace).toDouble();
      double newKi = command.substring(firstSpace + 1, secondSpace).toDouble();
      double newKd = command.substring(secondSpace + 1).toDouble();
      
      if (newKp >= 0 && newKi >= 0 && newKd >= 0) {
        Kp = newKp;
        Ki = newKi;
        Kd = newKd;
        myPID.SetTunings(Kp, Ki, Kd);
        dualPrintln("PID constants updated:");
        dualPrintln("  Kp: " + String(Kp));
        dualPrintln("  Ki: " + String(Ki));
        dualPrintln("  Kd: " + String(Kd));
      } else {
        dualPrintln("Invalid PID values. Must be non-negative.");
      }
    } else {
      dualPrintln("Usage: setpid <kp> <ki> <kd>");
    }
  }
  else if (command == "arm") {
    systemArmed = true;
    dualPrintln("System ARMED - Automatic PID Control Mode");
    // Move to neutral position when arming
    moveServoToPosition(calibration.neutralPosition);
  }
  else if (command == "disarm") {
    systemArmed = false;
    dualPrintln("System DISARMED - Manual Control Mode");
    // Move to neutral position when disarming
    moveServoToPosition(calibration.neutralPosition);
  }
  else if (command == "status") {
    printDetailedStatus();
  }
  else if (command.startsWith("calibrate ")) {
    // Handle calibration commands
    String subCommand = command.substring(10);
    subCommand.trim();
    
    if (subCommand.startsWith("set_min ")) {
      int value = subCommand.substring(8).toInt();
      if (value >= 0 && value <= 180 && value < calibration.maxPosition) {
        calibration.minPosition = value;
        moveServoToPosition(value);
        saveCalibrationData();
        // Update PID output limits
        myPID.SetOutputLimits(calibration.minPosition, calibration.maxPosition);
        dualPrintln("Minimum position set to: " + String(value) + "°");
      } else {
        dualPrintln("Invalid minimum position. Must be 0-180 and less than max position (" + String(calibration.maxPosition) + "°)");
      }
    }
    else if (subCommand.startsWith("set_max ")) {
      int value = subCommand.substring(8).toInt();
      if (value >= 0 && value <= 180 && value > calibration.minPosition) {
        calibration.maxPosition = value;
        moveServoToPosition(value);
        saveCalibrationData();
        // Update PID output limits
        myPID.SetOutputLimits(calibration.minPosition, calibration.maxPosition);
        dualPrintln("Maximum position set to: " + String(value) + "°");
      } else {
        dualPrintln("Invalid maximum position. Must be 0-180 and greater than min position (" + String(calibration.minPosition) + "°)");
      }
    }
    else if (subCommand.startsWith("set_neutral ")) {
      int value = subCommand.substring(12).toInt();
      if (value >= calibration.minPosition && value <= calibration.maxPosition) {
        calibration.neutralPosition = value;
        moveServoToPosition(value);
        saveCalibrationData();
        dualPrintln("Neutral position set to: " + String(value) + "°");
      } else {
        dualPrintln("Invalid neutral position. Must be between min (" + String(calibration.minPosition) + "°) and max (" + String(calibration.maxPosition) + "°)");
      }
    }
    else if (subCommand.startsWith("direction ")) {
      String direction = subCommand.substring(10);
      direction.trim();
      direction.toLowerCase();
      
      if (direction == "normal") {
        calibration.direction = true;
        saveCalibrationData();
        dualPrintln("Servo direction set to: NORMAL");
        // Move to neutral to show direction change
        moveServoToPosition(calibration.neutralPosition);
      } else if (direction == "reversed") {
        calibration.direction = false;
        saveCalibrationData();
        dualPrintln("Servo direction set to: REVERSED");
        // Move to neutral to show direction change
        moveServoToPosition(calibration.neutralPosition);
      } else {
        dualPrintln("Invalid direction. Use 'normal' or 'reversed'");
      }
    }
    else {
      dualPrintln("Unknown calibration command. Available:");
      dualPrintln("  calibrate set_min <value>     - Set minimum position (0-180)");
      dualPrintln("  calibrate set_max <value>     - Set maximum position (0-180)");
      dualPrintln("  calibrate set_neutral <value> - Set neutral position");
      dualPrintln("  calibrate direction <normal|reversed> - Set direction");
    }
  }
  else if (command == "help") {
    printHelp();
  }
  else {
    dualPrintln("Unknown command: " + command);
    dualPrintln("Type 'help' for available commands.");
  }
}

void updateSystemState() {
  // System is armed if either arm switch is pressed OR armed via serial
  bool shouldBeArmed = systemArmed || armSwitch;
  
  if (shouldBeArmed && !systemArmed) {
    systemArmed = true;
    dualPrintln("System ARMED via switch - Automatic PID Control Mode");
    // Move to neutral position when arming
    moveServoToPosition(calibration.neutralPosition);
  } else if (!shouldBeArmed && systemArmed && !armSwitch) {
    // Only disarm if switch is released and not armed via serial
    systemArmed = false;
    dualPrintln("System DISARMED via switch - Manual Control Mode");
    // Move to neutral position when disarming
    moveServoToPosition(calibration.neutralPosition);
  }
}

void runPIDControl() {
  // Compute PID output
  if (myPID.Compute()) {
    // Map PID output to servo position (PID output limits are already set to calibrated range)
    int targetPosition = (int)pidOutput;
    servoPosition = applyCalibration(targetPosition);
    clutchServo.write(servoPosition);
  }
}

void runManualControl() {
  // Map potentiometer value (0-4095 for ESP32 12-bit ADC) to calibrated servo range
  int targetPosition = map(manualPotValue, 0, 4095, calibration.minPosition, calibration.maxPosition);
  servoPosition = applyCalibration(targetPosition);
  clutchServo.write(servoPosition);
}

void updateOutputs() {
  // Update arm light - solid on when armed (automatic), flashing when disarmed (manual)
  if (systemArmed) {
    // Solid on when armed (automatic mode)
    digitalWrite(armLightPin, HIGH);
  } else {
    // Flashing when disarmed (manual mode)
    unsigned long currentTime = millis();
    if (currentTime - lastLEDFlash >= ledFlashInterval) {
      ledState = !ledState;
      digitalWrite(armLightPin, ledState);
      lastLEDFlash = currentTime;
    }
  }
}

void printStatus() {
  dualPrint("RPM: ");
  dualPrint(String(currentRPM));
  dualPrint(" | Target: ");
  dualPrint(String(setpointRPM));
  dualPrint(" | Servo: ");
  dualPrint(String(servoPosition));
  dualPrint("° | Mode: ");
  dualPrint(systemArmed ? "AUTO" : "MANUAL");
  dualPrint(" | PID Out: ");
  dualPrintln(String(pidOutput));
}

void printDetailedStatus() {
  dualPrintln("=== EMC Type 1 Controller Status ===");
  dualPrintln("Sensor Readings:");
  
  // Show pulse count and frequency information
  noInterrupts();
  unsigned long currentPulseCount = pulseCount;
  interrupts();
  
  dualPrintln("  RPM Sensor: Digital pulse train on pin 19");
  dualPrintln("  Current RPM: " + String(currentRPM));
  dualPrintln("  Pulse Count (current interval): " + String(currentPulseCount));
  dualPrintln("  Potentiometer: " + String(potValue));
  dualPrintln("  Manual Control Pot: " + String(manualPotValue));
  dualPrintln("  Arm Switch: " + String(armSwitch ? "PRESSED" : "RELEASED"));

  dualPrintln();
  
  dualPrintln("Control Parameters:");
  dualPrintln("  Target RPM: " + String(setpointRPM));
  dualPrintln("  PID Kp: " + String(Kp));
  dualPrintln("  PID Ki: " + String(Ki));
  dualPrintln("  PID Kd: " + String(Kd));
  dualPrintln();
  
  dualPrintln("Servo Calibration:");
  dualPrintln("  Min Position: " + String(calibration.minPosition) + "°");
  dualPrintln("  Max Position: " + String(calibration.maxPosition) + "°");
  dualPrintln("  Neutral Position: " + String(calibration.neutralPosition) + "°");
  dualPrintln("  Direction: " + String(calibration.direction ? "NORMAL" : "REVERSED"));
  dualPrintln();
  
  dualPrintln("System State:");
  dualPrintln("  Mode: " + String(systemArmed ? "AUTOMATIC" : "MANUAL"));
  dualPrintln("  Armed: " + String(systemArmed ? "YES" : "NO"));
  dualPrintln("  Servo Position: " + String(servoPosition) + "°");
  dualPrintln("  PID Output: " + String(pidOutput));
  dualPrintln("  Arm Light: " + String(digitalRead(armLightPin) ? "ON" : "OFF"));
  dualPrintln("====================================");
}

void printHelp() {
  dualPrintln("=== EMC Type 1 Controller Commands ===");
  dualPrintln("setrpm <value>     - Set target RPM (1-10000)");
  dualPrintln("setpid <kp> <ki> <kd> - Set PID constants");
  dualPrintln("calibrate set_min <value> - Set minimum servo position (0-180)");
  dualPrintln("calibrate set_max <value> - Set maximum servo position (0-180)");
  dualPrintln("calibrate set_neutral <value> - Set neutral servo position");
  dualPrintln("calibrate direction <normal|reversed> - Set servo direction");
  dualPrintln("arm                - Arm system (automatic PID mode)");
  dualPrintln("disarm             - Disarm system (manual control mode)");
  dualPrintln("status             - Show detailed status");
  dualPrintln("help               - Show this help");
  dualPrintln("");
  dualPrintln("CALIBRATION:");
  dualPrintln("  Use calibration commands to set servo limits and behavior");
  dualPrintln("  Servo moves to position in real-time for visual confirmation");
  dualPrintln("  Settings are saved to EEPROM automatically");
  dualPrintln("");
  dualPrintln("MODES:");
  dualPrintln("  AUTOMATIC: System armed, PID controls servo within calibrated range");
  dualPrintln("  MANUAL: System disarmed, pin 35 potentiometer controls servo within calibrated range");
  dualPrintln("=======================================");
}