#include <Arduino.h>
#include <PID_v1.h>
#include <ESP32Servo.h>
#include "BluetoothSerial.h"
#include <Preferences.h>
#include <math.h>

// ===== EMC Type 1 Controller for ESP32 =====
// Features:
// - Hydraulic clutch PID control
// - Manual potentiometer mapping with calibration
// - Safety override system
// - RPM measurement (PERIOD-BASED, interrupt-driven)
// - RPM smoothing (EMA) + user command setalpha
// - Servo control
// - Bluetooth Classic communication
// - Pre-PID arming position (pidStartPosition) + command setstart
// - PID aggressiveness scaling
// - User-selectable PPR (1,2,4) with auto-scaled setpoint
// - User-settable PID sample time (10–200 ms)
// - SAVE command + dirty flag (ONLY saves to NVS when user runs 'save')
// - Fix: take 'now = micros()' BEFORE disabling interrupts to avoid stale lastPulse timeout race
// - Fix: ISR updates lastPulseMicros ONLY for ACCEPTED pulses (prevents rejected/noise pulses corrupting period)
// - Update: Persist ALL user-defined setup parameters (setrpm, setpid, aggressiveness, pidStartPosition)
// - Update: Telemetry modes + rate, persisted, with commands:
//     telemetry auto|on|off
//     telemetry rate <ms>

// ===== Pin Definitions =====
const int rpmSensorPin = 19;
const int potentiometerPin = 34;
const int manualPotPin = 35;
const int servoPin = 18;
const int armLightPin = 2;
const int armSwitchPin = 21;

// ===== Preferences =====
Preferences preferences;

// ===== Dirty Flag =====
bool settingsDirty = false;

// ===== Servo calibration =====
int min_position = 0;
int max_position = 180;
int neutral_position = 90;
bool direction_reversed = false;

// Pre-PID start position (for arming sequence) — persisted
int pidStartPosition = 50;

// Manual potentiometer calibration
int manualPotMin = 0;
int manualPotMax = 4095;

// ===== RPM (period-based) =====
// pulsesPerRevolution (PPR) is user selectable: 1, 2, or 4
int pulsesPerRevolution = 1; // persisted

// IMPORTANT:
// lastPulseMicros is the timestamp of the LAST *ACCEPTED* tach pulse.
// Noise/rejected pulses MUST NOT update this value, otherwise the next valid dt is corrupted.
volatile unsigned long lastPulseMicros = 0;

// pulsePeriodMicros stores the most recent ACCEPTED period between pulses.
volatile unsigned long pulsePeriodMicros = 0;

// Flag indicating a fresh period is available to readSensors()
volatile bool newPeriodAvailable = false;

// Optional debug: count of accepted pulses
volatile unsigned long pulseCount = 0;

// Noise rejection / timeout
const unsigned long minPulsePeriodMicros = 200; // reject absurdly fast edges (noise)
const unsigned long rpmTimeoutMicros = 300000;  // if no accepted pulse for 0.30s -> RPM = 0

// RPM smoothing (EMA): alpha in 0.10–0.50 recommended
double rpmFilterAlpha = 0.30; // persisted

// ===== Sensor readings =====
int potValue = 0;
int manualPotValue = 0;
bool armSwitch = false;

// ===== System state =====
bool systemArmed = false;

// ===== LED flashing =====
unsigned long lastLEDFlash = 0;
const unsigned long ledFlashInterval = 500;
const unsigned long ledFlashIntervalOverride = 250;
bool ledState = false;

// ===== Safety override =====
bool overrideEnabled = false;
bool safetyOverrideActive = false;
int overrideThreshold = 3500;
bool armSwitchPreviousState = false;

// ===== PID control =====
// Persisted: setpointRPM, Kp/Ki/Kd, pidAggressiveness
double setpointRPM = 1000.0;
double currentRPM = 0.0;
double pidOutput = 0.0;
double Kp = 2.0, Ki = 5.0, Kd = 1.0;

double pidAggressiveness = 1.0; // 0.1–3.0
int pidSampleTimeMs = 100;      // 10–200 ms, persisted

// ===== Servo =====
Servo clutchServo;
int servoPosition = 90;

// ===== PID =====
PID myPID(&currentRPM, &pidOutput, &setpointRPM, Kp, Ki, Kd, DIRECT);

// ===== Serial/Bluetooth input =====
String inputString = "";
bool stringComplete = false;

BluetoothSerial SerialBT;
String btInputString = "";
bool btStringComplete = false;

// ===== Telemetry Control (Persisted) =====
// Desired default: MANUAL + telemetry OFF, then start streaming when ARMED.
// We support three telemetry modes:
//
// AUTO: telemetryEnabled follows systemArmed
// ON:   telemetryEnabled always true
// OFF:  telemetryEnabled always false
enum TelemetryMode : int {
  TELE_AUTO = 0,
  TELE_ON   = 1,
  TELE_OFF  = 2
};

TelemetryMode telemetryMode = TELE_AUTO;   // persisted
bool telemetryEnabled = false;             // derived runtime from telemetryMode + armed
unsigned long telemetryIntervalMs = 500;   // persisted stream rate (ms)
unsigned long lastTelemetryTime = 0;

// Rate limits (keep sane and prevent flooding)
const unsigned long telemetryRateMinMs = 50;
const unsigned long telemetryRateMaxMs = 5000;

// ===== Helpers =====
// "Event" output: always prints (USB + BT if connected)
void dualPrintln(String message) {
  Serial.println(message);
  if (SerialBT.hasClient()) SerialBT.println(message);
}
void dualPrint(String message) {
  Serial.print(message);
  if (SerialBT.hasClient()) SerialBT.print(message);
}

// "Telemetry" output: only prints when telemetryEnabled == true
void telePrintln(String message) {
  if (!telemetryEnabled) return;
  Serial.println(message);
  if (SerialBT.hasClient()) SerialBT.println(message);
}
void telePrint(String message) {
  if (!telemetryEnabled) return;
  Serial.print(message);
  if (SerialBT.hasClient()) SerialBT.print(message);
}

static const char* telemetryModeToString(TelemetryMode m) {
  switch (m) {
    case TELE_AUTO: return "AUTO";
    case TELE_ON:   return "ON";
    case TELE_OFF:  return "OFF";
    default:        return "AUTO";
  }
}

void applyTelemetryPolicy() {
  // Derive telemetryEnabled from mode + armed state
  if (telemetryMode == TELE_ON) telemetryEnabled = true;
  else if (telemetryMode == TELE_OFF) telemetryEnabled = false;
  else telemetryEnabled = systemArmed; // AUTO
}

// ===== Forward Decls =====
void IRAM_ATTR rpmPulseISR();
void readSensors();
void processInput();
void processCommand(String command);
void updateSystemState();
bool attemptArm();
void disarmSystem(const String &reason);
void runPIDControl();
void runManualControl();
void updateOutputs();
int applyCalibration(int position);

void processCalibrationCommand(String command);
void processSafetyCommand(String command);

void printStatus();          // telemetry stream
void printDetailedStatus();  // on-demand, always prints
void printHelp();
void printCalibrationStatus();

void saveCalibrationData();
void loadCalibrationData();

bool setPPR(int newPPR, bool autoScaleSetpoint = true);
bool setPidSampleTime(int newMs);
bool setRpmAlpha(double newAlpha);
bool setStartPosition(int newPos);

bool setTelemetryMode(TelemetryMode m);
bool setTelemetryRate(unsigned long ms);

// ===== Setup =====
void setup() {
  Serial.begin(115200);

  loadCalibrationData();  // loads persisted values (if any)
  settingsDirty = false;  // clean after load

  SerialBT.begin("EMC_Type_1_Controller");
  Serial.println("Bluetooth initialized. Device name: EMC_Type_1_Controller");

  pinMode(rpmSensorPin, INPUT_PULLUP);
  pinMode(potentiometerPin, INPUT);
  pinMode(manualPotPin, INPUT);
  pinMode(armLightPin, OUTPUT);
  pinMode(armSwitchPin, INPUT_PULLUP);

  analogReadResolution(12);
  analogSetPinAttenuation(potentiometerPin, ADC_11db);
  analogSetPinAttenuation(manualPotPin, ADC_11db);

  attachInterrupt(digitalPinToInterrupt(rpmSensorPin), rpmPulseISR, FALLING);

  clutchServo.attach(servoPin);
  servoPosition = neutral_position;
  clutchServo.write(servoPosition);

  myPID.SetMode(AUTOMATIC);
  myPID.SetOutputLimits(min_position, max_position);
  myPID.SetSampleTime(pidSampleTimeMs);
  myPID.SetTunings(Kp, Ki, Kd);

  digitalWrite(armLightPin, LOW);

  inputString.reserve(200);
  btInputString.reserve(200);

  // Default safe state
  systemArmed = false;
  safetyOverrideActive = false;

  // Apply telemetry policy based on loaded settings + disarmed state
  applyTelemetryPolicy();
  lastTelemetryTime = 0;

  Serial.println("=== EMC Type 1 Controller Initialized ===");
  printCalibrationStatus();
  dualPrintln("Type 'help' for commands.");
  dualPrintln("Telemetry mode: " + String(telemetryModeToString(telemetryMode)) +
             " | rate: " + String(telemetryIntervalMs) + " ms");
}

// ===== Loop =====
void loop() {
  readSensors();
  processInput();
  updateSystemState();

  if (systemArmed) runPIDControl();
  else runManualControl();

  updateOutputs();

  // Telemetry stream only when enabled
  if (telemetryEnabled && (millis() - lastTelemetryTime >= telemetryIntervalMs)) {
    printStatus();
    lastTelemetryTime = millis();
  }

  // delay removed for maximum responsiveness
}

// ===== ISR =====
// Period-based tach capture with noise rejection.
// lastPulseMicros is updated ONLY when pulse is ACCEPTED (dt >= minPulsePeriodMicros).
void IRAM_ATTR rpmPulseISR() {
  const unsigned long now = micros();
  const unsigned long dt  = now - lastPulseMicros;  // lastPulseMicros = last ACCEPTED pulse time

  if (dt >= minPulsePeriodMicros) {
    lastPulseMicros = now;
    pulsePeriodMicros = dt;
    newPeriodAvailable = true;
    pulseCount++;
  }
}

// ===== Sensor Reading =====
void readSensors() {
  // Capture now BEFORE disabling interrupts to avoid stale lastPulse timeout race
  const unsigned long now = micros();

  unsigned long period;
  unsigned long lastPulse;
  bool hasNew;

  noInterrupts();
  period = pulsePeriodMicros;
  lastPulse = lastPulseMicros;   // last accepted pulse
  hasNew = newPeriodAvailable;
  newPeriodAvailable = false;
  interrupts();

  if (now - lastPulse > rpmTimeoutMicros) {
    currentRPM = 0.0;
  } else if (hasNew && period > 0 && pulsesPerRevolution > 0) {
    const double rpmInstant = 60000000.0 / (period * (double)pulsesPerRevolution);

    if (currentRPM <= 0.0) currentRPM = rpmInstant;
    else currentRPM = (1.0 - rpmFilterAlpha) * currentRPM + rpmFilterAlpha * rpmInstant;
  }

  potValue = analogRead(potentiometerPin);
  manualPotValue = analogRead(manualPotPin);
  armSwitch = !digitalRead(armSwitchPin);
}

// ===== Input Processing =====
void processInput() {
  while (Serial.available()) {
    char inChar = (char)Serial.read();
    if (inChar == '\n') stringComplete = true;
    else inputString += inChar;
  }

  while (SerialBT.available()) {
    char inChar = (char)SerialBT.read();
    if (inChar == '\n') btStringComplete = true;
    else btInputString += inChar;
  }

  if (stringComplete) {
    processCommand(inputString);
    inputString = "";
    stringComplete = false;
  }
  if (btStringComplete) {
    processCommand(btInputString);
    btInputString = "";
    btStringComplete = false;
  }
}

// ===== Commands =====
void processCommand(String command) {
  command.trim();
  command.toLowerCase();

  if (command.startsWith("setrpm ")) {
    double newSetpoint = command.substring(7).toDouble();
    if (newSetpoint > 0 && newSetpoint <= 100000) {
      setpointRPM = newSetpoint;
      settingsDirty = true;
      dualPrintln("Target RPM set to: " + String(setpointRPM) + " | (UNSAVED)");
    } else dualPrintln("Invalid RPM value");
  }
  else if (command.startsWith("setpid ")) {
    int firstSpace = command.indexOf(' ', 7);
    int secondSpace = command.indexOf(' ', firstSpace + 1);
    if (firstSpace > 0 && secondSpace > 0) {
      double newKp = command.substring(7, firstSpace).toDouble();
      double newKi = command.substring(firstSpace + 1, secondSpace).toDouble();
      double newKd = command.substring(secondSpace + 1).toDouble();
      if (newKp >= 0 && newKi >= 0 && newKd >= 0) {
        Kp = newKp; Ki = newKi; Kd = newKd;
        myPID.SetTunings(Kp, Ki, Kd);
        settingsDirty = true;
        dualPrintln("PID constants updated: Kp=" + String(Kp) + " Ki=" + String(Ki) + " Kd=" + String(Kd) + " | (UNSAVED)");
      } else dualPrintln("Invalid PID values");
    } else dualPrintln("Usage: setpid <kp> <ki> <kd>");
  }
  else if (command.startsWith("aggressiveness ")) {
    double value = command.substring(14).toDouble();
    if (value >= 0.1 && value <= 3.0) {
      pidAggressiveness = value;
      settingsDirty = true;
      dualPrintln("PID aggressiveness set to: " + String(pidAggressiveness) + " | (UNSAVED)");
    } else dualPrintln("Aggressiveness value out of range (0.1-3.0)");
  }
  else if (command.startsWith("setstart ")) {
    int v = command.substring(9).toInt();
    if (!setStartPosition(v)) dualPrintln("Invalid start position (must be within servo limits)");
  }
  else if (command.startsWith("setsample ")) {
    int newMs = command.substring(10).toInt();
    if (!setPidSampleTime(newMs)) dualPrintln("Invalid sample time. Range: 10–200 ms");
  }
  else if (command.startsWith("setalpha ")) {
    double a = command.substring(9).toDouble();
    if (!setRpmAlpha(a)) dualPrintln("Invalid alpha. Recommended range: 0.10–0.50");
  }
  else if (command.startsWith("ppr ")) {
    int newPPR = command.substring(4).toInt();
    if (!setPPR(newPPR, true)) dualPrintln("Invalid PPR. Allowed: 1, 2, 4");
  }
  else if (command.startsWith("telemetry ")) {
    String arg = command.substring(10);
    arg.trim();

    if (arg == "auto") {
      setTelemetryMode(TELE_AUTO);
    } else if (arg == "on") {
      setTelemetryMode(TELE_ON);
    } else if (arg == "off") {
      setTelemetryMode(TELE_OFF);
    } else if (arg.startsWith("rate ")) {
      unsigned long ms = (unsigned long)arg.substring(5).toInt();
      if (!setTelemetryRate(ms)) {
        dualPrintln("Invalid telemetry rate. Range: " + String(telemetryRateMinMs) +
                   "–" + String(telemetryRateMaxMs) + " ms");
      }
    } else {
      dualPrintln("Usage:");
      dualPrintln("  telemetry auto|on|off");
      dualPrintln("  telemetry rate <ms>");
    }
  }
  else if (command == "save") {
    saveCalibrationData();
    settingsDirty = false;
    dualPrintln("Saved. (settingsDirty = false)");
  }
  else if (command == "dirty") {
    dualPrintln(String("settingsDirty = ") + (settingsDirty ? "true" : "false"));
  }
  else if (command.startsWith("calibrate ")) {
    processCalibrationCommand(command.substring(10));
  }
  else if (command.startsWith("safety ")) {
    processSafetyCommand(command.substring(7));
  }
  else if (command == "arm") {
    attemptArm();
  }
  else if (command == "disarm") {
    disarmSystem("System DISARMED");
  }
  else if (command == "status") {
    printDetailedStatus();
  }
  else if (command == "help") {
    printHelp();
  }
  else {
    dualPrintln("Unknown command");
    dualPrintln("Type 'help' for available commands.");
  }
}

// ===== Telemetry setters (persisted via save) =====
bool setTelemetryMode(TelemetryMode m) {
  if (m != TELE_AUTO && m != TELE_ON && m != TELE_OFF) return false;

  if (telemetryMode == m) {
    dualPrintln("Telemetry mode unchanged (" + String(telemetryModeToString(telemetryMode)) + ")");
    return true;
  }

  telemetryMode = m;
  settingsDirty = true;

  applyTelemetryPolicy();
  if (telemetryEnabled) lastTelemetryTime = 0; // immediate print on next loop

  dualPrintln("Telemetry mode set to: " + String(telemetryModeToString(telemetryMode)) +
             " | telemetryEnabled: " + String(telemetryEnabled ? "true" : "false") +
             " | (UNSAVED)");
  return true;
}

bool setTelemetryRate(unsigned long ms) {
  if (ms < telemetryRateMinMs || ms > telemetryRateMaxMs) return false;

  if (telemetryIntervalMs == ms) {
    dualPrintln("Telemetry rate unchanged (" + String(telemetryIntervalMs) + " ms)");
    return true;
  }

  telemetryIntervalMs = ms;
  settingsDirty = true;

  if (telemetryEnabled) lastTelemetryTime = 0; // immediate print on next loop

  dualPrintln("Telemetry rate set to: " + String(telemetryIntervalMs) + " ms | (UNSAVED)");
  return true;
}

// ===== Disarm helper =====
void disarmSystem(const String &reason) {
  systemArmed = false;

  applyTelemetryPolicy(); // AUTO mode will turn telemetry off when disarmed

  dualPrintln(reason);
}

// ===== Set Start Position (persisted) =====
bool setStartPosition(int newPos) {
  if (newPos < min_position || newPos > max_position) return false;
  if (newPos == pidStartPosition) {
    dualPrintln("Start position unchanged (" + String(pidStartPosition) + ")");
    return true;
  }
  pidStartPosition = newPos;
  settingsDirty = true;
  dualPrintln("Pre-PID start position set to: " + String(pidStartPosition) + " | (UNSAVED)");
  return true;
}

// ===== PPR Setter =====
bool setPPR(int newPPR, bool autoScaleSetpoint) {
  if (!(newPPR == 1 || newPPR == 2 || newPPR == 4)) return false;
  if (newPPR == pulsesPerRevolution) {
    dualPrintln("PPR unchanged (" + String(pulsesPerRevolution) + ")");
    return true;
  }

  int oldPPR = pulsesPerRevolution;

  if (autoScaleSetpoint && newPPR > 0) {
    setpointRPM = setpointRPM * ((double)oldPPR / (double)newPPR);
  }

  pulsesPerRevolution = newPPR;
  settingsDirty = true;

  dualPrintln("PPR set to: " + String(pulsesPerRevolution) +
             " | Setpoint auto-scaled to: " + String(setpointRPM) +
             " | (UNSAVED)");
  return true;
}

// ===== PID Sample Time Setter =====
bool setPidSampleTime(int newMs) {
  if (newMs < 10 || newMs > 200) return false;
  if (newMs == pidSampleTimeMs) {
    dualPrintln("PID sample time unchanged (" + String(pidSampleTimeMs) + " ms)");
    return true;
  }

  pidSampleTimeMs = newMs;
  myPID.SetSampleTime(pidSampleTimeMs);
  settingsDirty = true;

  dualPrintln("PID sample time set to: " + String(pidSampleTimeMs) + " ms | (UNSAVED)");
  return true;
}

// ===== RPM Alpha Setter =====
bool setRpmAlpha(double newAlpha) {
  if (newAlpha < 0.10 || newAlpha > 0.50) return false;

  if (fabs(newAlpha - rpmFilterAlpha) < 0.0005) {
    dualPrintln("RPM filter alpha unchanged (" + String(rpmFilterAlpha, 2) + ")");
    return true;
  }

  rpmFilterAlpha = newAlpha;
  settingsDirty = true;

  dualPrintln("RPM filter alpha set to: " + String(rpmFilterAlpha, 2) + " | (UNSAVED)");
  return true;
}

// ===== PID & Manual Control =====
void runPIDControl() {
  if (myPID.Compute()) {
    double scaledOutput = pidOutput * pidAggressiveness;
    scaledOutput = constrain(scaledOutput, min_position, max_position);
    servoPosition = applyCalibration((int)scaledOutput);
    clutchServo.write(servoPosition);
  }
}

void runManualControl() {
  int rawPosition = map(manualPotValue, manualPotMin, manualPotMax, min_position, max_position);
  rawPosition = constrain(rawPosition, min_position, max_position);
  servoPosition = applyCalibration(rawPosition);
  clutchServo.write(servoPosition);
}

// ===== System State =====
void updateSystemState() {
  bool armSwitchCurrentState = armSwitch;

  // Safety override
  if (overrideEnabled && systemArmed) {
    if (manualPotValue > overrideThreshold && !safetyOverrideActive) {
      safetyOverrideActive = true;
      dualPrintln("SAFETY OVERRIDE TRIGGERED! PID still active.");
    }
    // Only disarm after pot drops below threshold
    else if (safetyOverrideActive && manualPotValue <= overrideThreshold) {
      safetyOverrideActive = false;
      disarmSystem("System disarmed after pot returned below threshold.");
    }
  }

  // Arm switch toggling
  if (armSwitchCurrentState && !armSwitchPreviousState) {
    attemptArm();
  }
  else if (!armSwitchCurrentState && armSwitchPreviousState && systemArmed) {
    disarmSystem("System DISARMED via switch");
  }

  armSwitchPreviousState = armSwitchCurrentState;
}

// ===== Arming =====
bool attemptArm() {
  if (overrideEnabled && manualPotValue > overrideThreshold) {
    dualPrintln("Cannot arm: Pot above threshold");
    return false;
  }

  servoPosition = applyCalibration(pidStartPosition);
  clutchServo.write(servoPosition);

  systemArmed = true;
  safetyOverrideActive = false;

  applyTelemetryPolicy();
  if (telemetryEnabled) lastTelemetryTime = 0; // immediate print on next loop

  dualPrintln("System ARMED - Automatic PID Mode");
  return true;
}

// ===== Outputs =====
void updateOutputs() {
  if (safetyOverrideActive) {
    if (millis() - lastLEDFlash >= ledFlashIntervalOverride) {
      ledState = !ledState;
      digitalWrite(armLightPin, ledState);
      lastLEDFlash = millis();
    }
    return;
  }

  if (systemArmed) {
    digitalWrite(armLightPin, HIGH);
    return;
  }

  if (millis() - lastLEDFlash >= ledFlashInterval) {
    ledState = !ledState;
    digitalWrite(armLightPin, ledState);
    lastLEDFlash = millis();
  }
}

// ===== Calibration Helpers =====
int applyCalibration(int position) {
  position = constrain(position, min_position, max_position);
  if (direction_reversed) position = max_position - (position - min_position);
  return position;
}

// ===== Calibration Commands =====
void processCalibrationCommand(String command) {
  command.trim(); command.toLowerCase();

  if (command.startsWith("set_min ")) {
    int value = command.substring(8).toInt();
    if (value >= 0 && value < max_position) {
      min_position = value;
      if (neutral_position < min_position) neutral_position = min_position;
      myPID.SetOutputLimits(min_position, max_position);
      pidStartPosition = constrain(pidStartPosition, min_position, max_position);
      servoPosition = applyCalibration(min_position);
      clutchServo.write(servoPosition);
      settingsDirty = true;
      dualPrintln("Minimum position set | (UNSAVED)");
    } else dualPrintln("Invalid min position");
  }
  else if (command.startsWith("set_max ")) {
    int value = command.substring(8).toInt();
    if (value > min_position && value <= 180) {
      max_position = value;
      if (neutral_position > max_position) neutral_position = max_position;
      myPID.SetOutputLimits(min_position, max_position);
      pidStartPosition = constrain(pidStartPosition, min_position, max_position);
      servoPosition = applyCalibration(max_position);
      clutchServo.write(servoPosition);
      settingsDirty = true;
      dualPrintln("Maximum position set | (UNSAVED)");
    } else dualPrintln("Invalid max position");
  }
  else if (command.startsWith("set_neutral ")) {
    int value = command.substring(12).toInt();
    if (value >= min_position && value <= max_position) {
      neutral_position = value;
      servoPosition = applyCalibration(neutral_position);
      clutchServo.write(servoPosition);
      settingsDirty = true;
      dualPrintln("Neutral position set | (UNSAVED)");
    } else dualPrintln("Invalid neutral position");
  }
  else if (command.startsWith("direction ")) {
    int value = command.substring(10).toInt();
    if (value == 0 || value == 1) {
      direction_reversed = (value == 1);
      servoPosition = applyCalibration(servoPosition);
      clutchServo.write(servoPosition);
      settingsDirty = true;
      dualPrintln("Direction set | (UNSAVED)");
    } else dualPrintln("Invalid direction");
  }
  else if (command.startsWith("pot_min ")) {
    int value = command.substring(8).toInt();
    if (value >= 0 && value < manualPotMax) {
      manualPotMin = value;
      settingsDirty = true;
      dualPrintln("Manual pot min set | (UNSAVED)");
    } else dualPrintln("Invalid pot min");
  }
  else if (command.startsWith("pot_max ")) {
    int value = command.substring(8).toInt();
    if (value > manualPotMin && value <= 4095) {
      manualPotMax = value;
      settingsDirty = true;
      dualPrintln("Manual pot max set | (UNSAVED)");
    } else dualPrintln("Invalid pot max");
  }
  else {
    dualPrintln("Unknown calibration command");
  }
}

// ===== Safety Commands =====
void processSafetyCommand(String command) {
  command.trim(); command.toLowerCase();

  if (command == "enable") {
    overrideEnabled = true;
    settingsDirty = true;
    dualPrintln("Safety override ENABLED | (UNSAVED)");
  }
  else if (command == "disable") {
    overrideEnabled = false;
    safetyOverrideActive = false;
    settingsDirty = true;
    dualPrintln("Safety override DISABLED | (UNSAVED)");
  }
  else if (command.startsWith("set_threshold ")) {
    int value = command.substring(14).toInt();
    if (value >= manualPotMin && value <= manualPotMax) {
      overrideThreshold = value;
      settingsDirty = true;
      dualPrintln("Safety threshold set | (UNSAVED)");
    } else dualPrintln("Invalid threshold");
  }
  else {
    dualPrintln("Unknown safety command");
  }
}

// ===== Status & Print =====
// Telemetry stream (only prints when telemetryEnabled == true)
void printStatus() {
  telePrint("RPM: " + String(currentRPM) +
            " | Target: " + String(setpointRPM) +
            " | Servo: " + String(servoPosition) + "°" +
            " | Mode: " + (systemArmed ? "AUTO" : "MANUAL") +
            " | PID Out: " + String(pidOutput) +
            " | Agg: " + String(pidAggressiveness, 2) +
            " | PPR: " + String(pulsesPerRevolution) +
            " | Ts: " + String(pidSampleTimeMs) + "ms" +
            " | Alpha: " + String(rpmFilterAlpha, 2) +
            " | Tele: " + String(telemetryModeToString(telemetryMode)) + "@" + String(telemetryIntervalMs) + "ms" +
            " | " + (settingsDirty ? "UNSAVED" : "SAVED"));
  telePrintln("");
}

// On-demand status (always prints)
void printDetailedStatus() {
  dualPrintln("=== STATUS ===");
  dualPrintln("RPM: " + String(currentRPM));
  dualPrintln("Target RPM: " + String(setpointRPM));
  dualPrintln("Servo: " + String(servoPosition) + "°");
  dualPrintln("Mode: " + String(systemArmed ? "AUTO" : "MANUAL"));
  dualPrintln("PID Out: " + String(pidOutput));
  dualPrintln("PID Gains: Kp=" + String(Kp, 4) + " Ki=" + String(Ki, 4) + " Kd=" + String(Kd, 4));
  dualPrintln("Aggressiveness: " + String(pidAggressiveness, 2));
  dualPrintln("Pre-PID Start Position: " + String(pidStartPosition));
  dualPrintln("PPR: " + String(pulsesPerRevolution));
  dualPrintln("PID Sample Time: " + String(pidSampleTimeMs) + " ms");
  dualPrintln("RPM Filter Alpha: " + String(rpmFilterAlpha, 2));
  dualPrintln("Accepted Pulses Count (since boot): " + String((unsigned long)pulseCount));
  dualPrintln("Telemetry Mode: " + String(telemetryModeToString(telemetryMode)));
  dualPrintln("Telemetry Rate: " + String(telemetryIntervalMs) + " ms");
  dualPrintln(String("telemetryEnabled: ") + (telemetryEnabled ? "true" : "false"));
  dualPrintln(String("settingsDirty: ") + (settingsDirty ? "true" : "false"));
  dualPrintln("================");
}

void printHelp() {
  dualPrintln("Commands:");
  dualPrintln("  setrpm <rpm>                 [UNSAVED until 'save']");
  dualPrintln("  setpid <kp> <ki> <kd>        [UNSAVED until 'save']");
  dualPrintln("  aggressiveness <0.1-3.0>     [UNSAVED until 'save']");
  dualPrintln("  setstart <deg>               (pre-PID start pos) [UNSAVED until 'save']");
  dualPrintln("  setsample <10-200>           (PID sample time ms) [UNSAVED until 'save']");
  dualPrintln("  setalpha <0.10-0.50>         (RPM EMA alpha)      [UNSAVED until 'save']");
  dualPrintln("  ppr <1|2|4>                  (auto-scales setpoint) [UNSAVED until 'save']");
  dualPrintln("  telemetry auto|on|off        (stream policy)      [UNSAVED until 'save']");
  dualPrintln("  telemetry rate <ms>          (50–5000 ms)         [UNSAVED until 'save']");
  dualPrintln("  calibrate ...                (servo/pot calib)    [UNSAVED until 'save']");
  dualPrintln("  safety ...                   (override settings) [UNSAVED until 'save']");
  dualPrintln("  save                         (write ALL settings to NVS)");
  dualPrintln("  dirty                        (prints settingsDirty)");
  dualPrintln("  arm | disarm");
  dualPrintln("  status | help");
}

void printCalibrationStatus() {
  dualPrintln("=== Calibration Status ===");
  dualPrintln("Servo Min: " + String(min_position) +
             " Max: " + String(max_position) +
             " Neutral: " + String(neutral_position));
  dualPrintln("Direction: " + String(direction_reversed ? "REVERSED" : "NORMAL"));
  dualPrintln("Pot Min: " + String(manualPotMin) +
             " Max: " + String(manualPotMax));
  dualPrintln("Safety Threshold: " + String(overrideThreshold));
  dualPrintln("Safety Enabled: " + String(overrideEnabled ? "YES" : "NO"));
  dualPrintln("Pre-PID Start Position: " + String(pidStartPosition));
  dualPrintln("Target RPM (setpoint): " + String(setpointRPM));
  dualPrintln("PID Gains: Kp=" + String(Kp, 4) + " Ki=" + String(Ki, 4) + " Kd=" + String(Kd, 4));
  dualPrintln("Aggressiveness: " + String(pidAggressiveness, 2));
  dualPrintln("PPR (pulses/rev): " + String(pulsesPerRevolution));
  dualPrintln("PID Sample Time: " + String(pidSampleTimeMs) + " ms");
  dualPrintln("RPM Filter Alpha: " + String(rpmFilterAlpha, 2));
  dualPrintln("Telemetry: " + String(telemetryModeToString(telemetryMode)) +
             " @ " + String(telemetryIntervalMs) + " ms");
  dualPrintln("===========================");
}

// ===== Preferences =====
// NOTE: Because you chose "Only save on save", values are written ONLY here.
void saveCalibrationData() {
  preferences.begin("emc_calibration", false);

  // Servo / pot calibration
  preferences.putInt("min_pos", min_position);
  preferences.putInt("max_pos", max_position);
  preferences.putInt("neutral_pos", neutral_position);
  preferences.putBool("direction", direction_reversed);

  preferences.putInt("pot_min", manualPotMin);
  preferences.putInt("pot_max", manualPotMax);

  // Safety
  preferences.putInt("override_thresh", overrideThreshold);
  preferences.putBool("override_en", overrideEnabled);

  // RPM/PID config
  preferences.putInt("ppr", pulsesPerRevolution);
  preferences.putInt("pid_ts", pidSampleTimeMs);
  preferences.putInt("rpm_alpha_x100", (int)lround(rpmFilterAlpha * 100.0));

  // Persist ALL user-defined setup parameters
  preferences.putInt("start_pos", pidStartPosition);

  preferences.putDouble("setpoint", setpointRPM);
  preferences.putDouble("kp", Kp);
  preferences.putDouble("ki", Ki);
  preferences.putDouble("kd", Kd);
  preferences.putDouble("aggr", pidAggressiveness);

  // Telemetry settings (persisted)
  preferences.putInt("tele_mode", (int)telemetryMode);
  preferences.putInt("tele_ms", (int)telemetryIntervalMs);

  preferences.end();
  dualPrintln("Saved ALL settings to NVS.");
}

void loadCalibrationData() {
  preferences.begin("emc_calibration", false);

  // Servo / pot calibration
  min_position = preferences.getInt("min_pos", 0);
  max_position = preferences.getInt("max_pos", 180);
  neutral_position = preferences.getInt("neutral_pos", 90);
  direction_reversed = preferences.getBool("direction", false);

  manualPotMin = preferences.getInt("pot_min", 0);
  manualPotMax = preferences.getInt("pot_max", 4095);
  if (manualPotMin >= manualPotMax) manualPotMin = 0;

  // Safety
  overrideThreshold = preferences.getInt("override_thresh", (int)(manualPotMax * 0.85));
  overrideThreshold = constrain(overrideThreshold, manualPotMin, manualPotMax);
  overrideEnabled = preferences.getBool("override_en", false);

  // RPM/PID config
  int loadedPPR = preferences.getInt("ppr", 1);
  pulsesPerRevolution = (loadedPPR == 1 || loadedPPR == 2 || loadedPPR == 4) ? loadedPPR : 1;

  int loadedTs = preferences.getInt("pid_ts", 100);
  pidSampleTimeMs = constrain(loadedTs, 10, 200);

  int alphaX100 = preferences.getInt("rpm_alpha_x100", 30);
  double loadedAlpha = alphaX100 / 100.0;
  rpmFilterAlpha = constrain(loadedAlpha, 0.10, 0.50);

  // Persisted user-defined setup params
  pidStartPosition = preferences.getInt("start_pos", pidStartPosition);
  pidStartPosition = constrain(pidStartPosition, min_position, max_position);

  double loadedSetpoint = preferences.getDouble("setpoint", setpointRPM);
  if (loadedSetpoint > 0 && loadedSetpoint <= 100000) setpointRPM = loadedSetpoint;

  double loadedKp = preferences.getDouble("kp", Kp);
  double loadedKi = preferences.getDouble("ki", Ki);
  double loadedKd = preferences.getDouble("kd", Kd);
  if (loadedKp >= 0) Kp = loadedKp;
  if (loadedKi >= 0) Ki = loadedKi;
  if (loadedKd >= 0) Kd = loadedKd;

  double loadedAggr = preferences.getDouble("aggr", pidAggressiveness);
  if (loadedAggr >= 0.1 && loadedAggr <= 3.0) pidAggressiveness = loadedAggr;

  // Telemetry persisted settings
  int loadedTeleMode = preferences.getInt("tele_mode", (int)TELE_AUTO);
  if (loadedTeleMode < 0 || loadedTeleMode > 2) loadedTeleMode = (int)TELE_AUTO;
  telemetryMode = (TelemetryMode)loadedTeleMode;

  int loadedTeleMs = preferences.getInt("tele_ms", 500);
  if (loadedTeleMs < (int)telemetryRateMinMs) loadedTeleMs = telemetryRateMinMs;
  if (loadedTeleMs > (int)telemetryRateMaxMs) loadedTeleMs = telemetryRateMaxMs;
  telemetryIntervalMs = (unsigned long)loadedTeleMs;

  preferences.end();
  dualPrintln("Calibration/settings loaded from NVS.");
}
