#include <Arduino.h>
#include <PID_v1.h>
#include <ESP32Servo.h>
#include "BluetoothSerial.h"
#include <Preferences.h>
#include <math.h>

// ===== EMC Type 1 Controller for ESP32 =====
// Features:
// - Hydraulic clutch PID control
// - Manual potentiometer mapping with calibration
// - Safety override system
// - RPM measurement (PERIOD-BASED, interrupt-driven)
// - RPM smoothing (EMA) + user command setalpha
// - Servo control
// - Bluetooth Classic communication
// - Pre-PID arming position (pidStartPosition) + command setstart
// - PID aggressiveness scaling
// - User-selectable PPR (1,2,4) with auto-scaled setpoint
// - User-settable PID sample time (10–200 ms)
// - SAVE command + dirty flag (ONLY saves to NVS when user runs 'save')
// - Fix: take 'now = micros()' BEFORE disabling interrupts to avoid stale lastPulse timeout race
// - Fix: ISR updates lastPulseMicros ONLY for ACCEPTED pulses (prevents rejected/noise pulses corrupting period)
// - Update: Persist ALL user-defined setup parameters (setrpm, setpid, aggressiveness, pidStartPosition)

// ===== Pin Definitions =====
const int rpmSensorPin = 19;
const int potentiometerPin = 34;
const int manualPotPin = 35;
const int servoPin = 18;
const int armLightPin = 2;
const int armSwitchPin = 21;

// ===== Preferences =====
Preferences preferences;

// ===== Dirty Flag =====
bool settingsDirty = false;

// ===== Servo calibration =====
int min_position = 0;
int max_position = 180;
int neutral_position = 90;
bool direction_reversed = false;

// Pre-PID start position (for arming sequence) — now persisted
int pidStartPosition = 50;

// Manual potentiometer calibration
int manualPotMin = 0;
int manualPotMax = 4095;

// ===== RPM (period-based) =====
// pulsesPerRevolution (PPR) is user selectable: 1, 2, or 4
int pulsesPerRevolution = 1; // persisted

// IMPORTANT:
// lastPulseMicros is the timestamp of the LAST *ACCEPTED* tach pulse.
// Noise/rejected pulses MUST NOT update this value, otherwise the next valid dt is corrupted.
volatile unsigned long lastPulseMicros = 0;

// pulsePeriodMicros stores the most recent ACCEPTED period between pulses.
volatile unsigned long pulsePeriodMicros = 0;

// Flag indicating a fresh period is available to readSensors()
volatile bool newPeriodAvailable = false;

// Optional debug: count of accepted pulses
volatile unsigned long pulseCount = 0;

// Noise rejection / timeout
const unsigned long minPulsePeriodMicros = 200; // reject absurdly fast edges (noise)
const unsigned long rpmTimeoutMicros = 300000;  // if no accepted pulse for 0.30s -> RPM = 0

// RPM smoothing (EMA): alpha in 0.10–0.50 recommended
double rpmFilterAlpha = 0.30; // persisted

// ===== Sensor readings =====
int potValue = 0;
int manualPotValue = 0;
bool armSwitch = false;

// ===== System state =====
bool systemArmed = false;

// ===== LED flashing =====
unsigned long lastLEDFlash = 0;
const unsigned long ledFlashInterval = 500;
const unsigned long ledFlashIntervalOverride = 250;
bool ledState = false;

// ===== Safety override =====
bool overrideEnabled = false;
bool safetyOverrideActive = false;
int overrideThreshold = 3500;
bool armSwitchPreviousState = false;

// ===== PID control =====
// Now persisted: setpointRPM, Kp/Ki/Kd, pidAggressiveness
double setpointRPM = 1000.0;
double currentRPM = 0.0;
double pidOutput = 0.0;
double Kp = 2.0, Ki = 5.0, Kd = 1.0;

double pidAggressiveness = 1.0; // 0.1–3.0
int pidSampleTimeMs = 100;      // 10–200 ms, persisted

// ===== Servo =====
Servo clutchServo;
int servoPosition = 90;

// ===== PID =====
PID myPID(&currentRPM, &pidOutput, &setpointRPM, Kp, Ki, Kd, DIRECT);

// ===== Serial/Bluetooth input =====
String inputString = "";
bool stringComplete = false;

BluetoothSerial SerialBT;
String btInputString = "";
bool btStringComplete = false;

// ===== Timing =====
unsigned long lastPrintTime = 0;
const unsigned long printInterval = 500;

// ===== Helpers =====
void dualPrintln(String message) { Serial.println(message); SerialBT.println(message); }
void dualPrint(String message) { Serial.print(message); SerialBT.print(message); }

// ===== Forward Decls =====
void IRAM_ATTR rpmPulseISR();
void readSensors();
void processInput();
void processCommand(String command);
void updateSystemState();
bool attemptArm();
void runPIDControl();
void runManualControl();
void updateOutputs();
int applyCalibration(int position);

void processCalibrationCommand(String command);
void processSafetyCommand(String command);

void printStatus();
void printDetailedStatus();
void printHelp();
void printCalibrationStatus();

void saveCalibrationData();
void loadCalibrationData();

bool setPPR(int newPPR, bool autoScaleSetpoint = true);
bool setPidSampleTime(int newMs);
bool setRpmAlpha(double newAlpha);
bool setStartPosition(int newPos);

// ===== Setup =====
void setup() {
  Serial.begin(115200);

  loadCalibrationData();        // loads persisted values (if any)
  settingsDirty = false;        // clean after load

  SerialBT.begin("EMC_Type_1_Controller");
  Serial.println("Bluetooth initialized. Device name: EMC_Type_1_Controller");

  pinMode(rpmSensorPin, INPUT_PULLUP);
  pinMode(potentiometerPin, INPUT);
  pinMode(manualPotPin, INPUT);
  pinMode(armLightPin, OUTPUT);
  pinMode(armSwitchPin, INPUT_PULLUP);

  analogReadResolution(12);
  analogSetPinAttenuation(potentiometerPin, ADC_11db);
  analogSetPinAttenuation(manualPotPin, ADC_11db);

  attachInterrupt(digitalPinToInterrupt(rpmSensorPin), rpmPulseISR, FALLING);

  clutchServo.attach(servoPin);
  servoPosition = neutral_position;
  clutchServo.write(servoPosition);

  myPID.SetMode(AUTOMATIC);
  myPID.SetOutputLimits(min_position, max_position);
  myPID.SetSampleTime(pidSampleTimeMs);
  myPID.SetTunings(Kp, Ki, Kd);          // apply loaded tunings (if any)

  digitalWrite(armLightPin, LOW);

  inputString.reserve(200);
  btInputString.reserve(200);

  Serial.println("=== EMC Type 1 Controller Initialized ===");
  printCalibrationStatus();
  printStatus();
}

// ===== Loop =====
void loop() {
  readSensors();
  processInput();
  updateSystemState();

  if (systemArmed) runPIDControl();
  else runManualControl();

  updateOutputs();

  if (millis() - lastPrintTime >= printInterval) {
    printStatus();
    lastPrintTime = millis();
  }

  // delay removed for maximum responsiveness
  // (Optional cooperative yield: delay(1);)
}

// ===== ISR =====
// Period-based tach capture with noise rejection.
// lastPulseMicros is updated ONLY when pulse is ACCEPTED (dt >= minPulsePeriodMicros).
void IRAM_ATTR rpmPulseISR() {
  const unsigned long now = micros();
  const unsigned long dt  = now - lastPulseMicros;  // lastPulseMicros = last ACCEPTED pulse time

  if (dt >= minPulsePeriodMicros) {
    lastPulseMicros = now;
    pulsePeriodMicros = dt;
    newPeriodAvailable = true;
    pulseCount++;
  }
}

// ===== Sensor Reading =====
void readSensors() {
  // Capture now BEFORE disabling interrupts to avoid stale lastPulse timeout race
  const unsigned long now = micros();

  unsigned long period;
  unsigned long lastPulse;
  bool hasNew;

  noInterrupts();
  period = pulsePeriodMicros;
  lastPulse = lastPulseMicros;   // last accepted pulse
  hasNew = newPeriodAvailable;
  newPeriodAvailable = false;
  interrupts();

  if (now - lastPulse > rpmTimeoutMicros) {
    currentRPM = 0.0;
  } else if (hasNew && period > 0 && pulsesPerRevolution > 0) {
    const double rpmInstant = 60000000.0 / (period * (double)pulsesPerRevolution);

    if (currentRPM <= 0.0) currentRPM = rpmInstant;
    else currentRPM = (1.0 - rpmFilterAlpha) * currentRPM + rpmFilterAlpha * rpmInstant;
  }

  potValue = analogRead(potentiometerPin);
  manualPotValue = analogRead(manualPotPin);
  armSwitch = !digitalRead(armSwitchPin);
}

// ===== Input Processing =====
void processInput() {
  while (Serial.available()) {
    char inChar = (char)Serial.read();
    if (inChar == '\n') stringComplete = true;
    else inputString += inChar;
  }

  while (SerialBT.available()) {
    char inChar = (char)SerialBT.read();
    if (inChar == '\n') btStringComplete = true;
    else btInputString += inChar;
  }

  if (stringComplete) {
    processCommand(inputString);
    inputString = "";
    stringComplete = false;
  }
  if (btStringComplete) {
    processCommand(btInputString);
    btInputString = "";
    btStringComplete = false;
  }
}

// ===== Commands =====
void processCommand(String command) {
  command.trim();
  command.toLowerCase();

  if (command.startsWith("setrpm ")) {
    double newSetpoint = command.substring(7).toDouble();
    if (newSetpoint > 0 && newSetpoint <= 100000) {
      setpointRPM = newSetpoint;
      settingsDirty = true;
      dualPrintln("Target RPM set to: " + String(setpointRPM) + " | (UNSAVED)");
    } else dualPrintln("Invalid RPM value");
  }
  else if (command.startsWith("setpid ")) {
    int firstSpace = command.indexOf(' ', 7);
    int secondSpace = command.indexOf(' ', firstSpace + 1);
    if (firstSpace > 0 && secondSpace > 0) {
      double newKp = command.substring(7, firstSpace).toDouble();
      double newKi = command.substring(firstSpace + 1, secondSpace).toDouble();
      double newKd = command.substring(secondSpace + 1).toDouble();
      if (newKp >= 0 && newKi >= 0 && newKd >= 0) {
        Kp = newKp; Ki = newKi; Kd = newKd;
        myPID.SetTunings(Kp, Ki, Kd);
        settingsDirty = true;
        dualPrintln("PID constants updated: Kp=" + String(Kp) + " Ki=" + String(Ki) + " Kd=" + String(Kd) + " | (UNSAVED)");
      } else dualPrintln("Invalid PID values");
    } else dualPrintln("Usage: setpid <kp> <ki> <kd>");
  }
  else if (command.startsWith("aggressiveness ")) {
    double value = command.substring(14).toDouble();
    if (value >= 0.1 && value <= 3.0) {
      pidAggressiveness = value;
      settingsDirty = true;
      dualPrintln("PID aggressiveness set to: " + String(pidAggressiveness) + " | (UNSAVED)");
    } else dualPrintln("Aggressiveness value out of range (0.1-3.0)");
  }
  else if (command.startsWith("setstart ")) {
    int v = command.substring(9).toInt();
    if (!setStartPosition(v)) dualPrintln("Invalid start position (must be within servo limits)");
  }
  else if (command.startsWith("setsample ")) {
    int newMs = command.substring(10).toInt();
    if (!setPidSampleTime(newMs)) dualPrintln("Invalid sample time. Range: 10–200 ms");
  }
  else if (command.startsWith("setalpha ")) {
    double a = command.substring(9).toDouble();
    if (!setRpmAlpha(a)) dualPrintln("Invalid alpha. Recommended range: 0.10–0.50");
  }
  else if (command.startsWith("ppr ")) {
    int newPPR = command.substring(4).toInt();
    if (!setPPR(newPPR, true)) dualPrintln("Invalid PPR. Allowed: 1, 2, 4");
  }
  else if (command == "save") {
    saveCalibrationData();
    settingsDirty = false;
    dualPrintln("Saved. (settingsDirty = false)");
  }
  else if (command == "dirty") {
    dualPrintln(String("settingsDirty = ") + (settingsDirty ? "true" : "false"));
  }
  else if (command.startsWith("calibrate ")) {
    processCalibrationCommand(command.substring(10));
  }
  else if (command.startsWith("safety ")) {
    processSafetyCommand(command.substring(7));
  }
  else if (command == "arm") {
    attemptArm();
  }
  else if (command == "disarm") {
    systemArmed = false;
    dualPrintln("System DISARMED");
  }
  else if (command == "status") {
    printDetailedStatus();
  }
  else if (command == "help") {
    printHelp();
  }
  else {
    dualPrintln("Unknown command");
    dualPrintln("Type 'help' for available commands.");
  }
}

// ===== Set Start Position (persisted) =====
bool setStartPosition(int newPos) {
  if (newPos < min_position || newPos > max_position) return false;
  if (newPos == pidStartPosition) {
    dualPrintln("Start position unchanged (" + String(pidStartPosition) + ")");
    return true;
  }
  pidStartPosition = newPos;
  settingsDirty = true;
  dualPrintln("Pre-PID start position set to: " + String(pidStartPosition) + " | (UNSAVED)");
  return true;
}

// ===== PPR Setter =====
bool setPPR(int newPPR, bool autoScaleSetpoint) {
  if (!(newPPR == 1 || newPPR == 2 || newPPR == 4)) return false;
  if (newPPR == pulsesPerRevolution) {
    dualPrintln("PPR unchanged (" + String(pulsesPerRevolution) + ")");
    return true;
  }

  int oldPPR = pulsesPerRevolution;

  if (autoScaleSetpoint && newPPR > 0) {
    setpointRPM = setpointRPM * ((double)oldPPR / (double)newPPR);
  }

  pulsesPerRevolution = newPPR;
  settingsDirty = true;

  dualPrintln("PPR set to: " + String(pulsesPerRevolution) +
             " | Setpoint auto-scaled to: " + String(setpointRPM) +
             " | (UNSAVED)");
  return true;
}

// ===== PID Sample Time Setter =====
bool setPidSampleTime(int newMs) {
  if (newMs < 10 || newMs > 200) return false;
  if (newMs == pidSampleTimeMs) {
    dualPrintln("PID sample time unchanged (" + String(pidSampleTimeMs) + " ms)");
    return true;
  }

  pidSampleTimeMs = newMs;
  myPID.SetSampleTime(pidSampleTimeMs);
  settingsDirty = true;

  dualPrintln("PID sample time set to: " + String(pidSampleTimeMs) + " ms | (UNSAVED)");
  return true;
}

// ===== RPM Alpha Setter =====
bool setRpmAlpha(double newAlpha) {
  if (newAlpha < 0.10 || newAlpha > 0.50) return false;

  if (fabs(newAlpha - rpmFilterAlpha) < 0.0005) {
    dualPrintln("RPM filter alpha unchanged (" + String(rpmFilterAlpha, 2) + ")");
    return true;
  }

  rpmFilterAlpha = newAlpha;
  settingsDirty = true;

  dualPrintln("RPM filter alpha set to: " + String(rpmFilterAlpha, 2) + " | (UNSAVED)");
  return true;
}

// ===== PID & Manual Control =====
void runPIDControl() {
  if (myPID.Compute()) {
    double scaledOutput = pidOutput * pidAggressiveness;
    scaledOutput = constrain(scaledOutput, min_position, max_position);
    servoPosition = applyCalibration((int)scaledOutput);
    clutchServo.write(servoPosition);
  }
}

void runManualControl() {
  int rawPosition = map(manualPotValue, manualPotMin, manualPotMax, min_position, max_position);
  rawPosition = constrain(rawPosition, min_position, max_position);
  servoPosition = applyCalibration(rawPosition);
  clutchServo.write(servoPosition);
}

// ===== System State =====
void updateSystemState() {
  bool armSwitchCurrentState = armSwitch;

  // Safety override
  if (overrideEnabled && systemArmed) {
    if (manualPotValue > overrideThreshold && !safetyOverrideActive) {
      safetyOverrideActive = true;
      dualPrintln("SAFETY OVERRIDE TRIGGERED! PID still active.");
    }
    // Only disarm after pot drops below threshold
    else if (safetyOverrideActive && manualPotValue <= overrideThreshold) {
      systemArmed = false;
      safetyOverrideActive = false;
      dualPrintln("System disarmed after pot returned below threshold.");
    }
  }

  // Arm switch toggling
  if (armSwitchCurrentState && !armSwitchPreviousState) attemptArm();
  else if (!armSwitchCurrentState && armSwitchPreviousState && systemArmed) {
    systemArmed = false;
    dualPrintln("System DISARMED via switch");
  }

  armSwitchPreviousState = armSwitchCurrentState;
}

// ===== Arming =====
bool attemptArm() {
  if (overrideEnabled && manualPotValue > overrideThreshold) {
    dualPrintln("Cannot arm: Pot above threshold");
    return false;
  }

  servoPosition = applyCalibration(pidStartPosition);
  clutchServo.write(servoPosition);

  systemArmed = true;
  safetyOverrideActive = false;
  dualPrintln("System ARMED - Automatic PID Mode");
  return true;
}

// ===== Outputs =====
void updateOutputs() {
  if (safetyOverrideActive) {
    if (millis() - lastLEDFlash >= ledFlashIntervalOverride) {
      ledState = !ledState;
      digitalWrite(armLightPin, ledState);
      lastLEDFlash = millis();
    }
    return;
  }

  if (systemArmed) {
    digitalWrite(armLightPin, HIGH);
    return;
  }

  if (millis() - lastLEDFlash >= ledFlashInterval) {
    ledState = !ledState;
    digitalWrite(armLightPin, ledState);
    lastLEDFlash = millis();
  }
}

// ===== Calibration Helpers =====
int applyCalibration(int position) {
  position = constrain(position, min_position, max_position);
  if (direction_reversed) position = max_position - (position - min_position);
  return position;
}

// ===== Calibration Commands =====
void processCalibrationCommand(String command) {
  command.trim(); command.toLowerCase();

  if (command.startsWith("set_min ")) {
    int value = command.substring(8).toInt();
    if (value >= 0 && value < max_position) {
      min_position = value;
      if (neutral_position < min_position) neutral_position = min_position;
      myPID.SetOutputLimits(min_position, max_position);
      // keep pidStartPosition valid if user tightens limits
      pidStartPosition = constrain(pidStartPosition, min_position, max_position);
      servoPosition = applyCalibration(min_position);
      clutchServo.write(servoPosition);
      settingsDirty = true;
      dualPrintln("Minimum position set | (UNSAVED)");
    } else dualPrintln("Invalid min position");
  }
  else if (command.startsWith("set_max ")) {
    int value = command.substring(8).toInt();
    if (value > min_position && value <= 180) {
      max_position = value;
      if (neutral_position > max_position) neutral_position = max_position;
      myPID.SetOutputLimits(min_position, max_position);
      pidStartPosition = constrain(pidStartPosition, min_position, max_position);
      servoPosition = applyCalibration(max_position);
      clutchServo.write(servoPosition);
      settingsDirty = true;
      dualPrintln("Maximum position set | (UNSAVED)");
    } else dualPrintln("Invalid max position");
  }
  else if (command.startsWith("set_neutral ")) {
    int value = command.substring(12).toInt();
    if (value >= min_position && value <= max_position) {
      neutral_position = value;
      servoPosition = applyCalibration(neutral_position);
      clutchServo.write(servoPosition);
      settingsDirty = true;
      dualPrintln("Neutral position set | (UNSAVED)");
    } else dualPrintln("Invalid neutral position");
  }
  else if (command.startsWith("direction ")) {
    int value = command.substring(10).toInt();
    if (value == 0 || value == 1) {
      direction_reversed = (value == 1);
      servoPosition = applyCalibration(servoPosition);
      clutchServo.write(servoPosition);
      settingsDirty = true;
      dualPrintln("Direction set | (UNSAVED)");
    } else dualPrintln("Invalid direction");
  }
  else if (command.startsWith("pot_min ")) {
    int value = command.substring(8).toInt();
    if (value >= 0 && value < manualPotMax) {
      manualPotMin = value;
      settingsDirty = true;
      dualPrintln("Manual pot min set | (UNSAVED)");
    } else dualPrintln("Invalid pot min");
  }
  else if (command.startsWith("pot_max ")) {
    int value = command.substring(8).toInt();
    if (value > manualPotMin && value <= 4095) {
      manualPotMax = value;
      settingsDirty = true;
      dualPrintln("Manual pot max set | (UNSAVED)");
    } else dualPrintln("Invalid pot max");
  }
  else {
    dualPrintln("Unknown calibration command");
  }
}

// ===== Safety Commands =====
void processSafetyCommand(String command) {
  command.trim(); command.toLowerCase();

  if (command == "enable") {
    overrideEnabled = true;
    settingsDirty = true;
    dualPrintln("Safety override ENABLED | (UNSAVED)");
  }
  else if (command == "disable") {
    overrideEnabled = false;
    safetyOverrideActive = false;
    settingsDirty = true;
    dualPrintln("Safety override DISABLED | (UNSAVED)");
  }
  else if (command.startsWith("set_threshold ")) {
    int value = command.substring(14).toInt();
    if (value >= manualPotMin && value <= manualPotMax) {
      overrideThreshold = value;
      settingsDirty = true;
      dualPrintln("Safety threshold set | (UNSAVED)");
    } else dualPrintln("Invalid threshold");
  }
  else {
    dualPrintln("Unknown safety command");
  }
}

// ===== Status & Print =====
void printStatus() {
  dualPrint("RPM: " + String(currentRPM) +
            " | Target: " + String(setpointRPM) +
            " | Servo: " + String(servoPosition) + "°" +
            " | Mode: " + (systemArmed ? "AUTO" : "MANUAL") +
            " | PID Out: " + String(pidOutput) +
            " | Agg: " + String(pidAggressiveness, 2) +
            " | PPR: " + String(pulsesPerRevolution) +
            " | Ts: " + String(pidSampleTimeMs) + "ms" +
            " | Alpha: " + String(rpmFilterAlpha, 2) +
            " | " + (settingsDirty ? "UNSAVED" : "SAVED"));
  dualPrintln("");
}

void printDetailedStatus() {
  dualPrintln("=== STATUS ===");
  dualPrintln("RPM: " + String(currentRPM));
  dualPrintln("Target RPM: " + String(setpointRPM));
  dualPrintln("Servo: " + String(servoPosition) + "°");
  dualPrintln("Mode: " + String(systemArmed ? "AUTO" : "MANUAL"));
  dualPrintln("PID Out: " + String(pidOutput));
  dualPrintln("PID Gains: Kp=" + String(Kp, 4) + " Ki=" + String(Ki, 4) + " Kd=" + String(Kd, 4));
  dualPrintln("Aggressiveness: " + String(pidAggressiveness, 2));
  dualPrintln("Pre-PID Start Position: " + String(pidStartPosition));
  dualPrintln("PPR: " + String(pulsesPerRevolution));
  dualPrintln("PID Sample Time: " + String(pidSampleTimeMs) + " ms");
  dualPrintln("RPM Filter Alpha: " + String(rpmFilterAlpha, 2));
  dualPrintln("Accepted Pulses Count (since boot): " + String((unsigned long)pulseCount));
  dualPrintln(String("settingsDirty: ") + (settingsDirty ? "true" : "false"));
  dualPrintln("================");
}

void printHelp() {
  dualPrintln("Commands:");
  dualPrintln("  setrpm <rpm>                 [UNSAVED until 'save']");
  dualPrintln("  setpid <kp> <ki> <kd>        [UNSAVED until 'save']");
  dualPrintln("  aggressiveness <0.1-3.0>     [UNSAVED until 'save']");
  dualPrintln("  setstart <deg>               (pre-PID start pos) [UNSAVED until 'save']");
  dualPrintln("  setsample <10-200>           (PID sample time ms) [UNSAVED until 'save']");
  dualPrintln("  setalpha <0.10-0.50>         (RPM EMA alpha)      [UNSAVED until 'save']");
  dualPrintln("  ppr <1|2|4>                  (auto-scales setpoint) [UNSAVED until 'save']");
  dualPrintln("  calibrate ...                (servo/pot calib)    [UNSAVED until 'save']");
  dualPrintln("  safety ...                   (override settings) [UNSAVED until 'save']");
  dualPrintln("  save                         (write ALL settings to NVS)");
  dualPrintln("  dirty                        (prints settingsDirty)");
  dualPrintln("  arm | disarm");
  dualPrintln("  status | help");
}

void printCalibrationStatus() {
  dualPrintln("=== Calibration Status ===");
  dualPrintln("Servo Min: " + String(min_position) +
             " Max: " + String(max_position) +
             " Neutral: " + String(neutral_position));
  dualPrintln("Direction: " + String(direction_reversed ? "REVERSED" : "NORMAL"));
  dualPrintln("Pot Min: " + String(manualPotMin) +
             " Max: " + String(manualPotMax));
  dualPrintln("Safety Threshold: " + String(overrideThreshold));
  dualPrintln("Safety Enabled: " + String(overrideEnabled ? "YES" : "NO"));
  dualPrintln("Pre-PID Start Position: " + String(pidStartPosition));
  dualPrintln("Target RPM (setpoint): " + String(setpointRPM));
  dualPrintln("PID Gains: Kp=" + String(Kp, 4) + " Ki=" + String(Ki, 4) + " Kd=" + String(Kd, 4));
  dualPrintln("Aggressiveness: " + String(pidAggressiveness, 2));
  dualPrintln("PPR (pulses/rev): " + String(pulsesPerRevolution));
  dualPrintln("PID Sample Time: " + String(pidSampleTimeMs) + " ms");
  dualPrintln("RPM Filter Alpha: " + String(rpmFilterAlpha, 2));
  dualPrintln("===========================");
}

// ===== Preferences =====
// NOTE: Because you chose "Only save on save", values are written ONLY here.
void saveCalibrationData() {
  preferences.begin("emc_calibration", false);

  // Servo / pot calibration
  preferences.putInt("min_pos", min_position);
  preferences.putInt("max_pos", max_position);
  preferences.putInt("neutral_pos", neutral_position);
  preferences.putBool("direction", direction_reversed);

  preferences.putInt("pot_min", manualPotMin);
  preferences.putInt("pot_max", manualPotMax);

  // Safety
  preferences.putInt("override_thresh", overrideThreshold);
  preferences.putBool("override_en", overrideEnabled);

  // RPM/PID config
  preferences.putInt("ppr", pulsesPerRevolution);
  preferences.putInt("pid_ts", pidSampleTimeMs);
  preferences.putInt("rpm_alpha_x100", (int)lround(rpmFilterAlpha * 100.0));

  // Persist ALL user-defined setup parameters
  preferences.putInt("start_pos", pidStartPosition);

  preferences.putDouble("setpoint", setpointRPM);
  preferences.putDouble("kp", Kp);
  preferences.putDouble("ki", Ki);
  preferences.putDouble("kd", Kd);
  preferences.putDouble("aggr", pidAggressiveness);

  preferences.end();
  dualPrintln("Saved ALL settings to NVS.");
}

void loadCalibrationData() {
  preferences.begin("emc_calibration", false);

  // Servo / pot calibration
  min_position = preferences.getInt("min_pos", 0);
  max_position = preferences.getInt("max_pos", 180);
  neutral_position = preferences.getInt("neutral_pos", 90);
  direction_reversed = preferences.getBool("direction", false);

  manualPotMin = preferences.getInt("pot_min", 0);
  manualPotMax = preferences.getInt("pot_max", 4095);
  if (manualPotMin >= manualPotMax) manualPotMin = 0;

  // Safety
  overrideThreshold = preferences.getInt("override_thresh", (int)(manualPotMax * 0.85));
  overrideThreshold = constrain(overrideThreshold, manualPotMin, manualPotMax);
  overrideEnabled = preferences.getBool("override_en", false);

  // RPM/PID config
  int loadedPPR = preferences.getInt("ppr", 1);
  pulsesPerRevolution = (loadedPPR == 1 || loadedPPR == 2 || loadedPPR == 4) ? loadedPPR : 1;

  int loadedTs = preferences.getInt("pid_ts", 100);
  pidSampleTimeMs = constrain(loadedTs, 10, 200);

  int alphaX100 = preferences.getInt("rpm_alpha_x100", 30);
  double loadedAlpha = alphaX100 / 100.0;
  rpmFilterAlpha = constrain(loadedAlpha, 0.10, 0.50);

  // Persisted user-defined setup params
  pidStartPosition = preferences.getInt("start_pos", pidStartPosition);
  // keep within servo range (and within min/max calibration)
  pidStartPosition = constrain(pidStartPosition, min_position, max_position);

  double loadedSetpoint = preferences.getDouble("setpoint", setpointRPM);
  if (loadedSetpoint > 0 && loadedSetpoint <= 100000) setpointRPM = loadedSetpoint;

  double loadedKp = preferences.getDouble("kp", Kp);
  double loadedKi = preferences.getDouble("ki", Ki);
  double loadedKd = preferences.getDouble("kd", Kd);
  if (loadedKp >= 0) Kp = loadedKp;
  if (loadedKi >= 0) Ki = loadedKi;
  if (loadedKd >= 0) Kd = loadedKd;

  double loadedAggr = preferences.getDouble("aggr", pidAggressiveness);
  if (loadedAggr >= 0.1 && loadedAggr <= 3.0) pidAggressiveness = loadedAggr;

  preferences.end();
  dualPrintln("Calibration/settings loaded from NVS.");
}

